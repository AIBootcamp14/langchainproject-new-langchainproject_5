# 02. 프로젝트 목표 및 설계
> AI Agent와 RAG 시스템의 아키텍처 설계 및 기술적 목표

## 목차
1. [프로젝트 목표](#1-프로젝트-목표)
2. [개발 환경](#2-개발-환경)
3. [시스템 아키텍처](#3-시스템-아키텍처)
4. [AI Agent 설계](#4-ai-agent-설계)
5. [RAG 시스템 설계](#5-rag-시스템-설계)
6. [데이터베이스 설계](#6-데이터베이스-설계)
7. [기술 스택](#7-기술-스택)

---

## 1. 프로젝트 목표

### 슬라이드 1: 핵심 목표
**PPT 내용:**

```mermaid
graph TB
    subgraph Vision["🎯 비전"]
        direction LR
        V1[AI/ML 논문의<br/>대중화]
    end

    subgraph Goals["📌 핵심 목표"]
        direction LR
        G1[지능형<br/>질문 응답]
        G2[난이도별<br/>맞춤 답변]
        G3[최신 정보<br/>실시간 제공]
        G4[사용자<br/>편의성]
    end

    subgraph Metrics["📊 성과 지표"]
        direction LR
        M1[학습 시간<br/>50% 단축]
        M2[정확도<br/>85% 이상]
        M3[응답 시간<br/>3초 이내]
        M4[만족도<br/>90% 이상]
    end

    V1 --> G1 --> M1
    V1 --> G2 --> M2
    V1 --> G3 --> M3
    V1 --> G4 --> M4

    %% Subgraph 스타일
    style Vision fill:#e1f5ff,stroke:#01579b,stroke-width:3px,color:#000
    style Goals fill:#f3e5f5,stroke:#4a148c,stroke-width:3px,color:#000
    style Metrics fill:#e8f5e9,stroke:#1b5e20,stroke-width:3px,color:#000

    %% 노드 스타일 (Vision - 파랑 계열)
    style V1 fill:#90caf9,stroke:#1976d2,color:#000

    %% 노드 스타일 (Goals - 보라 계열)
    style G1 fill:#ce93d8,stroke:#7b1fa2,color:#000
    style G2 fill:#ba68c8,stroke:#7b1fa2,color:#fff
    style G3 fill:#ab47bc,stroke:#4a148c,color:#fff
    style G4 fill:#9c27b0,stroke:#4a148c,color:#fff

    %% 노드 스타일 (Metrics - 녹색 계열)
    style M1 fill:#a5d6a7,stroke:#388e3c,color:#000
    style M2 fill:#81c784,stroke:#2e7d32,color:#000
    style M3 fill:#81c784,stroke:#2e7d32,color:#000
    style M4 fill:#66bb6a,stroke:#2e7d32,color:#fff
```

**발표 스크립트:**
```
저희의 비전은 "AI/ML 논문의 대중화"입니다.
이를 위해 4가지 핵심 목표를 설정했습니다.
지능형 질문 응답으로 학습 시간을 50% 단축,
난이도별 맞춤 답변으로 85% 이상의 정확도 달성,
최신 정보 제공으로 3초 이내 응답,
사용자 편의성으로 90% 이상의 만족도를 목표로 합니다.
```

### 슬라이드 2: 기능 요구사항
**PPT 내용:**

| 구분 | 기능 | 상세 설명 | 우선순위 |
|------|------|-----------|----------|
| **필수** | AI Agent 라우팅 | 질문 분석 및 도구 자동 선택 | P0 |
| **필수** | RAG 검색 | 벡터 기반 논문 검색 | P0 |
| **필수** | 난이도별 답변 | Easy/Hard 모드 구분 | P0 |
| **필수** | 웹 검색 | 최신 논문 정보 검색 | P0 |
| **선택** | Text-to-SQL | 자연어 → SQL 변환 | P1 |
| **선택** | 성능 평가 | RAG 정확도 평가 | P2 |

**발표 스크립트:**
```
기능 요구사항은 필수와 선택으로 구분했습니다.
필수 기능인 AI Agent 라우팅, RAG 검색, 난이도별 답변,
웹 검색은 모두 100% 구현 완료했습니다.
추가로 Text-to-SQL과 성능 평가 시스템도 구현하여
프로젝트의 완성도를 높였습니다.
```

---

## 2. 개발 환경

### 슬라이드 3: 개발 환경 구성
**PPT 내용:**

```mermaid
graph LR
    subgraph OS["🖥️ 운영 체제"]
        direction TB
        W[Windows 11]
        WSL[WSL 24.04 LTS<br/>Ubuntu]
        W --> WSL
    end

    subgraph Python["🐍 Python 환경"]
        direction TB
        PY[Python 3.11.9]
        PYENV[pyenv 관리]
        VENV[가상환경<br/>langchain_py3_11_9]
        PY --> PYENV --> VENV
    end

    subgraph Tools["🛠️ 개발 도구"]
        direction TB
        VS[VS Code]
        GIT[Git/GitHub]
        VS --> GIT
    end

    OS --> Python --> Tools

    %% Subgraph 스타일
    style OS fill:#e1f5ff,stroke:#01579b,stroke-width:3px,color:#000
    style Python fill:#f3e5f5,stroke:#4a148c,stroke-width:3px,color:#000
    style Tools fill:#e8f5e9,stroke:#1b5e20,stroke-width:3px,color:#000

    %% 노드 스타일
    style W fill:#90caf9,stroke:#1976d2,color:#000
    style WSL fill:#64b5f6,stroke:#1976d2,color:#000
    style PY fill:#ce93d8,stroke:#7b1fa2,color:#000
    style PYENV fill:#ba68c8,stroke:#7b1fa2,color:#fff
    style VENV fill:#ab47bc,stroke:#4a148c,color:#fff
    style VS fill:#a5d6a7,stroke:#388e3c,color:#000
    style GIT fill:#81c784,stroke:#2e7d32,color:#000
```

**발표 스크립트:**
```
개발 환경은 Windows 11에 WSL Ubuntu를 설치하여
Linux 환경을 구축했습니다.
Python 3.11.9를 pyenv로 관리하고,
독립된 가상환경을 구성했습니다.
VS Code와 Git을 통해 효율적인 개발과 협업을 진행했습니다.
```

### 슬라이드 4: 패키지 의존성
**PPT 내용:**

| 카테고리 | 주요 패키지 | 버전 | 용도 |
|----------|-------------|------|------|
| **Framework** | langchain | 0.1.0 | RAG/Agent 통합 |
| | langgraph | 0.0.20 | 상태 기반 워크플로우 |
| **LLM** | openai | 1.6.1 | GPT-5 API |
| | langchain-openai | 0.0.2 | LangChain 통합 |
| **Database** | psycopg2-binary | 2.9.9 | PostgreSQL 연결 |
| | pgvector | 0.2.3 | 벡터 검색 |
| **UI** | streamlit | 1.28.2 | 웹 인터페이스 |
| **Search** | tavily-python | 0.3.0 | 웹 검색 API |
| **Document** | pypdf | 3.17.1 | PDF 처리 |
| | arxiv | 2.1.0 | 논문 수집 |

**발표 스크립트:**
```
프로젝트는 LangChain 0.1.0과 LangGraph 0.0.20을 기반으로
구축되었습니다. PostgreSQL과 pgvector로 데이터베이스를,
Streamlit으로 UI를 구현했습니다.
모든 패키지는 requirements.txt로 관리하여
재현 가능한 환경을 구축했습니다.
```

---

## 3. 시스템 아키텍처

### 슬라이드 5: 전체 시스템 구조
**PPT 내용:**

```mermaid
graph TB
    subgraph Frontend["🔸 Frontend Layer"]
        direction LR
        UI[Streamlit UI<br/>채팅 인터페이스]
    end

    subgraph Orchestration["🔹 Orchestration Layer"]
        direction LR
        AG[AI Agent<br/>LangGraph]
        RT[Router<br/>질문 분석]
        AG --> RT
    end

    subgraph Tools["🔺 Tools Layer"]
        direction LR
        T1[일반 답변]
        T2[RAG 검색]
        T3[웹 검색]
        T4[용어집]
        T5[논문 요약]
        T6[파일 저장]
    end

    subgraph LLM_["🤖 LLM Layer"]
        direction LR
        GPT[OpenAI<br/>GPT-5]
        Solar[Solar<br/>Pro2]
    end

    subgraph Data["💾 Data Layer"]
        direction LR
        PG[(PostgreSQL)]
        VEC[(pgvector)]
        FS[File System]
    end

    UI --> AG
    RT --> T1 & T2 & T3 & T4 & T5 & T6
    T1 & T2 & T3 & T4 & T5 --> GPT
    T1 & T2 & T3 & T4 & T5 --> Solar
    T2 & T4 --> VEC
    T2 & T4 --> PG
    T6 --> FS

    %% Subgraph 스타일
    style Frontend fill:#e1f5ff,stroke:#01579b,stroke-width:3px,color:#000
    style Orchestration fill:#f3e5f5,stroke:#4a148c,stroke-width:3px,color:#000
    style Tools fill:#fff3e0,stroke:#e65100,stroke-width:3px,color:#000
    style LLM_ fill:#e8f5e9,stroke:#1b5e20,stroke-width:3px,color:#000
    style Data fill:#ffebee,stroke:#c62828,stroke-width:3px,color:#000

    %% 노드 스타일
    style UI fill:#90caf9,stroke:#1976d2,color:#000
    style AG fill:#ce93d8,stroke:#7b1fa2,color:#000
    style RT fill:#ba68c8,stroke:#7b1fa2,color:#fff
    style GPT fill:#a5d6a7,stroke:#388e3c,color:#000
    style Solar fill:#81c784,stroke:#2e7d32,color:#000
```

**발표 스크립트:**
```
시스템은 5개 레이어로 구성됩니다.
Frontend는 Streamlit으로 구현한 채팅 인터페이스,
Orchestration은 LangGraph 기반 AI Agent,
Tools는 6가지 전문 도구,
LLM은 OpenAI와 Solar의 이중 구성,
Data는 PostgreSQL과 pgvector를 통합한 구조입니다.
```

### 슬라이드 6: 데이터 플로우
**PPT 내용:**

```mermaid
sequenceDiagram
    participant U as 사용자
    participant UI as Streamlit
    participant AG as AI Agent
    participant R as Router
    participant T as Tools
    participant LLM as LLM
    participant DB as Database

    U->>UI: 질문 입력
    UI->>AG: 요청 전달
    AG->>R: 질문 분석
    R->>R: 도구 선택
    R->>T: 도구 실행

    alt RAG 검색
        T->>DB: 벡터 검색
        DB-->>T: 유사 문서
    else 웹 검색
        T->>Web: API 호출
        Web-->>T: 검색 결과
    end

    T->>LLM: 프롬프트 생성
    LLM-->>T: 답변 생성
    T-->>AG: 결과 반환
    AG-->>UI: 최종 답변
    UI-->>U: 답변 표시
```

**발표 스크립트:**
```
데이터 플로우를 보시면,
사용자 질문이 들어오면 AI Agent가 Router를 통해
적절한 도구를 선택합니다.
도구는 필요한 데이터를 검색하고,
LLM에 전달하여 답변을 생성한 후
최종적으로 사용자에게 전달됩니다.
```

---

## 4. AI Agent 설계

### 슬라이드 7: LangGraph 기반 Agent
**PPT 내용:**

```mermaid
graph LR
    subgraph StateGraph["📊 LangGraph StateGraph"]
        direction TB
        START([시작])
        Router{라우터}

        subgraph Tools["도구 노드"]
            direction LR
            N1[일반 답변]
            N2[RAG 검색]
            N3[웹 검색]
            N4[용어집]
            N5[논문 요약]
            N6[파일 저장]
        end

        END([종료])

        START --> Router
        Router -->|일반| N1
        Router -->|RAG| N2
        Router -->|웹| N3
        Router -->|용어| N4
        Router -->|요약| N5
        Router -->|저장| N6
        N1 & N2 & N3 & N4 & N5 & N6 --> END
    end

    subgraph State["🔄 AgentState"]
        direction LR
        S1[question: str]
        S2[difficulty: str]
        S3[messages: list]
        S4[tool_choice: str]
        S5[final_answer: str]
    end

    %% Subgraph 스타일
    style StateGraph fill:#f3e5f5,stroke:#4a148c,stroke-width:3px,color:#000
    style State fill:#e8f5e9,stroke:#1b5e20,stroke-width:3px,color:#000

    %% 노드 스타일
    style START fill:#81c784,stroke:#388e3c,color:#000
    style Router fill:#ba68c8,stroke:#7b1fa2,color:#fff
    style END fill:#66bb6a,stroke:#2e7d32,color:#fff
```

**발표 스크립트:**
```
AI Agent는 LangGraph를 기반으로 구현했습니다.
StateGraph를 통해 복잡한 워크플로우를 관리하고,
AgentState로 대화 상태를 추적합니다.
라우터가 질문을 분석하여 6가지 도구 중
가장 적절한 도구를 자동으로 선택합니다.
```

### 슬라이드 8: 라우팅 로직
**PPT 내용:**

| 질문 패턴 | 선택 도구 | 예시 |
|-----------|-----------|------|
| 논문/연구/알고리즘 | RAG 검색 | "Transformer 논문 설명해줘" |
| 최신/2024/2025 | 웹 검색 | "2025년 최신 GPT 논문" |
| 용어/뜻/의미 | 용어집 | "Attention이 뭐야?" |
| 요약/정리 | 논문 요약 | "이 논문 요약해줘" |
| 저장/파일 | 파일 저장 | "대화 내용 저장해줘" |
| 기타 | 일반 답변 | "안녕하세요" |

**라우팅 정확도: 92%**

**발표 스크립트:**
```
라우팅 로직은 질문 패턴을 분석하여
적절한 도구를 선택합니다.
논문 관련 질문은 RAG 검색으로,
최신 정보는 웹 검색으로,
용어 설명은 용어집으로 라우팅됩니다.
테스트 결과 92%의 정확도를 달성했습니다.
```

---

## 5. RAG 시스템 설계

### 슬라이드 9: RAG 아키텍처
**PPT 내용:**

```mermaid
graph LR
    subgraph Input["🔸 입력"]
        direction TB
        PDF[논문 PDF<br/>50편]
    end

    subgraph Processing["🔹 전처리"]
        direction TB
        L[Document<br/>Loader]
        S[Text<br/>Splitter]
        E[Embedding<br/>생성]
        L --> S --> E
    end

    subgraph Storage["🔺 저장"]
        direction TB
        V[(pgvector<br/>벡터 DB)]
        P[(PostgreSQL<br/>메타데이터)]
    end

    subgraph Retrieval["🔶 검색"]
        direction TB
        R[Similarity<br/>Search]
        M[Metadata<br/>Filter]
        RR[Reranking<br/>(선택)]
        R --> RR
    end

    PDF --> L
    E --> V
    PDF --> P
    V --> R
    P --> M
    R & M --> Result[검색 결과]

    %% Subgraph 스타일
    style Input fill:#e1f5ff,stroke:#01579b,stroke-width:3px,color:#000
    style Processing fill:#f3e5f5,stroke:#4a148c,stroke-width:3px,color:#000
    style Storage fill:#fff3e0,stroke:#e65100,stroke-width:3px,color:#000
    style Retrieval fill:#e8f5e9,stroke:#1b5e20,stroke-width:3px,color:#000

    %% 노드 스타일
    style PDF fill:#90caf9,stroke:#1976d2,color:#000
    style L fill:#ce93d8,stroke:#7b1fa2,color:#000
    style S fill:#ba68c8,stroke:#7b1fa2,color:#fff
    style E fill:#ab47bc,stroke:#4a148c,color:#fff
    style V fill:#ffb74d,stroke:#e65100,color:#000
    style P fill:#ffa726,stroke:#ef6c00,color:#000
    style R fill:#a5d6a7,stroke:#388e3c,color:#000
    style M fill:#81c784,stroke:#2e7d32,color:#000
    style RR fill:#81c784,stroke:#2e7d32,color:#000
    style Result fill:#66bb6a,stroke:#2e7d32,color:#fff
```

**발표 스크립트:**
```
RAG 시스템은 논문 PDF를 로드하고,
RecursiveCharacterTextSplitter로 청크 분할한 후,
OpenAI Embeddings로 벡터화합니다.
pgvector에 벡터를 저장하고,
PostgreSQL에 메타데이터를 저장하여
하이브리드 검색을 구현했습니다.
```

### 슬라이드 10: 검색 최적화
**PPT 내용:**

| 최적화 기법 | 구현 내용 | 성능 개선 |
|-------------|-----------|-----------|
| **청크 크기** | 1000 tokens | 검색 정확도 +15% |
| **오버랩** | 200 tokens | 컨텍스트 연결성 향상 |
| **임베딩** | text-embedding-3-small | 비용 80% 절감 |
| **Top-K** | K=5 | 관련성 높은 결과 |
| **메타데이터 필터** | 년도, 카테고리 | 정밀도 +20% |
| **캐싱** | 임베딩 캐시 | 응답 속도 2배 |

**발표 스크립트:**
```
RAG 시스템을 여러 방면으로 최적화했습니다.
청크 크기를 1000 토큰으로 설정하여 정확도를 15% 향상,
임베딩 모델 최적화로 비용을 80% 절감,
캐싱을 통해 응답 속도를 2배 향상시켰습니다.
```

---

## 6. 데이터베이스 설계

### 슬라이드 11: DB 스키마
**PPT 내용:**

```mermaid
erDiagram
    papers ||--o{ paper_chunks : contains
    papers ||--o{ glossary : references
    papers {
        int id PK
        string title
        string authors
        int year
        string category
        text abstract
        timestamp created_at
    }

    paper_chunks {
        int id PK
        int paper_id FK
        text content
        vector embedding
        int chunk_index
        json metadata
    }

    glossary {
        int id PK
        string term
        text definition_easy
        text definition_hard
        string category
        vector embedding
    }

    conversations {
        int id PK
        string session_id
        text question
        text answer
        string difficulty
        timestamp created_at
    }
```

**발표 스크립트:**
```
데이터베이스는 4개의 핵심 테이블로 구성됩니다.
papers는 논문 메타데이터,
paper_chunks는 청크와 벡터 임베딩,
glossary는 용어 정의,
conversations는 대화 히스토리를 저장합니다.
pgvector를 통해 벡터 검색을 지원합니다.
```

### 슬라이드 12: 하이브리드 검색
**PPT 내용:**

| 검색 유형 | 방법 | 사용 사례 |
|-----------|------|-----------|
| **벡터 검색** | Cosine Similarity | 의미적 유사 문서 |
| **키워드 검색** | PostgreSQL FTS | 정확한 용어 매칭 |
| **메타데이터 필터** | SQL WHERE | 년도, 저자, 카테고리 |
| **하이브리드** | 벡터 + 키워드 + 메타 | 최적 검색 결과 |

**검색 파이프라인:**
```python
1. 벡터 검색 (Top-10)
2. 메타데이터 필터링
3. 키워드 부스팅
4. Reranking (선택)
5. Top-5 반환
```

**발표 스크립트:**
```
하이브리드 검색은 벡터 검색, 키워드 검색,
메타데이터 필터를 결합합니다.
먼저 벡터 유사도로 Top-10을 찾고,
메타데이터로 필터링한 후,
최종적으로 Top-5를 반환합니다.
```

---

## 7. 기술 스택

### 슬라이드 13: 기술 스택 구조
**PPT 내용:**

```mermaid
graph TB
    subgraph Language["🔤 Language & Runtime"]
        direction LR
        Python[Python 3.11.9]
        PYENV[pyenv]
        VENV[venv]
        Python --> PYENV --> VENV
    end

    subgraph Framework["🏗️ Framework"]
        direction LR
        LC[LangChain 0.1.0]
        LG[LangGraph 0.0.20]
        ST[Streamlit 1.28.2]
    end

    subgraph LLM_["🤖 LLM"]
        direction LR
        OAI[OpenAI GPT-5]
        SOL[Solar Pro2]
        EMB[text-embedding-3-small]
    end

    subgraph Database["💾 Database"]
        direction LR
        PG[PostgreSQL 15+]
        VEC[pgvector 0.5.0+]
        PG --> VEC
    end

    subgraph API["🌐 External API"]
        direction LR
        TAV[Tavily Search]
        ARX[arXiv API]
    end

    Language --> Framework
    Framework --> LLM_
    Framework --> Database
    Framework --> API

    %% Subgraph 스타일
    style Language fill:#e1f5ff,stroke:#01579b,stroke-width:3px,color:#000
    style Framework fill:#f3e5f5,stroke:#4a148c,stroke-width:3px,color:#000
    style LLM_ fill:#e8f5e9,stroke:#1b5e20,stroke-width:3px,color:#000
    style Database fill:#fff3e0,stroke:#e65100,stroke-width:3px,color:#000
    style API fill:#ffebee,stroke:#c62828,stroke-width:3px,color:#000

    %% 노드 스타일
    style Python fill:#90caf9,stroke:#1976d2,color:#000
    style LC fill:#ce93d8,stroke:#7b1fa2,color:#000
    style LG fill:#ba68c8,stroke:#7b1fa2,color:#fff
    style OAI fill:#a5d6a7,stroke:#388e3c,color:#000
    style SOL fill:#81c784,stroke:#2e7d32,color:#000
    style PG fill:#ffb74d,stroke:#e65100,color:#000
    style VEC fill:#ffa726,stroke:#ef6c00,color:#000
```

**발표 스크립트:**
```
기술 스택은 Python 3.11.9를 기반으로,
LangChain과 LangGraph로 AI Agent를 구현,
Streamlit으로 UI를 개발했습니다.
LLM은 OpenAI와 Solar를 이중으로 구성,
PostgreSQL과 pgvector로 데이터베이스를 통합했습니다.
```

### 슬라이드 14: 기술 선정 이유
**PPT 내용:**

| 기술 | 선정 이유 | 대안 검토 |
|------|-----------|-----------|
| **Python 3.11.9** | • LangChain 호환성<br/>• 성능 개선 (10-60%) | Python 3.10 (성능) |
| **LangGraph** | • 복잡한 워크플로우<br/>• 상태 관리 용이 | AutoGen (복잡) |
| **pgvector** | • PostgreSQL 통합<br/>• 단일 DB 솔루션 | Pinecone (비용) |
| **Streamlit** | • 빠른 개발<br/>• 채팅 UI 지원 | Gradio (제한적) |
| **Solar Pro2** | • 한국어 특화<br/>• 비용 효율 | Claude (API 제한) |
| **Tavily** | • AI 최적화<br/>• 구조화된 결과 | Google (복잡) |

**발표 스크립트:**
```
각 기술은 신중하게 선정했습니다.
Python 3.11.9는 LangChain과 완벽 호환되며 성능이 우수하고,
LangGraph는 복잡한 워크플로우 관리에 최적,
pgvector는 PostgreSQL과 통합되어 관리가 용이,
Streamlit은 빠른 프로토타이핑이 가능,
Solar Pro2는 한국어 성능과 비용 면에서 우수했습니다.
```

---

## 발표 준비 체크리스트

### 전체 발표 시간: 15분
- [ ] 프로젝트 목표 (2분)
- [ ] 개발 환경 (2분)
- [ ] 시스템 아키텍처 (2분)
- [ ] AI Agent 설계 (2분)
- [ ] RAG 시스템 설계 (3분)
- [ ] 데이터베이스 설계 (2분)
- [ ] 기술 스택 (2분)

### 핵심 메시지
1. **목표**: 학습 시간 50% 단축, 정확도 85% 이상
2. **환경**: Python 3.11.9 + WSL 기반 표준 개발 환경
3. **설계**: LangGraph 기반 AI Agent + 하이브리드 RAG
4. **기술**: 최적의 기술 스택 선정과 통합

### 준비물
- [ ] 아키텍처 다이어그램
- [ ] 개발 환경 설정 가이드
- [ ] 기술 비교표
- [ ] 성능 지표
- [ ] 코드 샘플