# 실험 폴더 구조 최종안 (종합 가이드)

## 문서 정보
- **작성일**: 2025-10-31
- **프로젝트명**: 논문 리뷰 챗봇 (AI Agent + RAG)
- **팀명**: 연결의 민족
- **목적**: 실험 결과를 체계적으로 기록하기 위한 종합 폴더 구조 정의

---

## 📋 목차

1. [전체 폴더 구조](#전체-폴더-구조)
2. [각 폴더 상세 설명](#각-폴더-상세-설명)
   - [metadata.json (메타데이터)](#1-metadatajson)
   - [tools/ (도구 실행 로그)](#2-tools-폴더)
   - [database/ (DB 관련)](#3-database-폴더)
   - [prompts/ (프롬프트)](#4-prompts-폴더)
   - [ui/ (Streamlit UI)](#5-ui-폴더)
   - [outputs/ (결과물)](#6-outputs-폴더)
   - [evaluation/ (평가 지표)](#7-evaluation-폴더)
   - [debug/ (디버그)](#8-debug-폴더)
3. [ExperimentManager 구현](#experimentmanager-구현)
4. [실제 사용 예시](#실제-사용-예시)
5. [폴더 검색 및 분석](#폴더-검색-및-분석)

---

## 전체 폴더 구조

```
experiments/
└── 20251031/                                # 날짜별 폴더 (YYYYMMDD)
    └── 20251031_103015_session_001/         # 시간_session_ID
        │
        ├── metadata.json                    # ⭐ 전체 실험 메타데이터
        ├── chatbot.log                      # 메인 실행 로그
        ├── config.yaml                      # 전체 설정
        │
        ├── tools/                           # 🔧 도구 실행 로그
        │   ├── rag_paper.log                # 논문 검색 로그
        │   ├── rag_glossary.log             # 용어집 검색 로그
        │   ├── web_search.log               # 웹 검색 로그
        │   ├── summary_paper.log            # 논문 요약 로그
        │   ├── file_save.log                # 파일 저장 로그
        │   └── general.log                  # 일반 답변 로그
        │
        ├── database/                        # 🗄️ DB 관련 기록
        │   ├── queries.sql                  # 실행된 SQL 쿼리 모음
        │   ├── pgvector_searches.json       # pgvector 검색 기록
        │   ├── search_results.json          # DB 검색 결과
        │   └── db_performance.json          # 쿼리 실행 시간 등
        │
        ├── prompts/                         # 💬 프롬프트 기록
        │   ├── system_prompt.txt            # 사용된 시스템 프롬프트
        │   ├── user_prompt.txt              # 사용자 질문 + 컨텍스트
        │   ├── final_prompt.txt             # LLM에 전달된 최종 프롬프트
        │   └── prompt_template.yaml         # 프롬프트 템플릿 정보
        │
        ├── ui/                              # 🖥️ UI 관련 기록
        │   ├── streamlit_session.json       # Streamlit 세션 상태
        │   ├── user_interactions.log        # 사용자 인터랙션 로그
        │   └── ui_events.json               # UI 이벤트 기록
        │
        ├── outputs/                         # 📄 생성된 결과물
        │   ├── response.txt                 # 최종 답변
        │   ├── summary.md                   # 요약본 (있을 경우)
        │   └── saved_file.txt               # 사용자가 저장 요청한 파일
        │
        ├── evaluation/                      # 📊 평가 지표
        │   ├── rag_metrics.json             # RAG 평가 지표
        │   ├── agent_accuracy.json          # Agent 정확도
        │   ├── latency_report.json          # 응답 시간 분석
        │   ├── cost_analysis.json           # 비용 분석
        │   └── test_results.json            # 테스트 결과
        │
        └── debug/                           # 🐛 디버그 정보 (선택)
            ├── agent_trace.json             # Agent 실행 추적
            ├── llm_tokens.json              # 토큰 사용량
            └── error_trace.log              # 에러 발생 시 스택 트레이스
```

---

## 각 폴더 상세 설명

### 1. metadata.json

**목적**: 전체 실험의 핵심 정보를 한 곳에 요약

**내용 예시**:
```json
{
  "session_id": "001",
  "start_time": "2025-10-31T10:30:15",
  "end_time": "2025-10-31T10:32:45",
  "difficulty": "easy",
  "tool_used": "rag_paper",
  "user_query": "RAG에 대해 알려줘",
  "success": true,
  "response_time_ms": 2500,
  "response_length": 450,
  "model": "gpt-4",
  "temperature": 0.7,
  "tokens_used": {
    "prompt": 1200,
    "completion": 800,
    "total": 2000
  },
  "db_queries_count": 4,
  "db_total_time_ms": 120
}
```

---

### 2. tools/ 폴더

**목적**: 6가지 AI Agent 도구의 실행 로그 저장

**특징**:
- 실행된 도구만 로그 파일 생성 (빈 파일 없음)
- 각 도구별 독립적인 Logger 사용

#### 2.1 rag_paper.log (논문 검색)

```
2025-10-31 10:30:25 | 논문 검색 시작
2025-10-31 10:30:25 | 검색 쿼리: "RAG에 대해 알려줘"
2025-10-31 10:30:25 | 임베딩 생성 완료 (dimension: 1536)
2025-10-31 10:30:25 | pgvector similarity_search 실행
2025-10-31 10:30:25 | Top-5 청크 검색 완료 (45ms)
2025-10-31 10:30:25 | 관련 논문 5개 발견
2025-10-31 10:30:25 | - [1] Retrieval-Augmented Generation (Patrick Lewis et al., 2020)
2025-10-31 10:30:25 | - [2] Dense Passage Retrieval (Vladimir Karpukhin et al., 2020)
2025-10-31 10:30:25 | - [3] REALM (Kelvin Guu et al., 2020)
2025-10-31 10:30:25 | PostgreSQL papers 테이블 조회 (12ms)
2025-10-31 10:30:25 | 컨텍스트 구성 완료 (총 1,234 tokens)
2025-10-31 10:30:25 | 논문 검색 완료
```

#### 2.2 rag_glossary.log (용어집 검색)

```
2025-10-31 10:30:26 | 용어집 검색 시작
2025-10-31 10:30:26 | 검색 용어: "Attention Mechanism"
2025-10-31 10:30:26 | glossary 테이블 조회
2025-10-31 10:30:26 | 용어 발견: term_id=42
2025-10-31 10:30:26 | 난이도: easy
2025-10-31 10:30:26 | 설명: "책을 읽을 때 중요한 부분에 집중하는 것처럼..."
2025-10-31 10:30:26 | 용어집 검색 완료 (8ms)
```

#### 2.3 web_search.log (웹 검색)

```
2025-10-31 14:25:43 | 웹 검색 시작
2025-10-31 14:25:43 | 검색 쿼리: "최신 Transformer 논문"
2025-10-31 14:25:43 | Tavily Search API 호출
2025-10-31 14:25:44 | 검색 결과 10개 수신
2025-10-31 14:25:44 | - [1] https://arxiv.org/abs/2023...
2025-10-31 14:25:44 | - [2] https://arxiv.org/abs/2024...
2025-10-31 14:25:44 | 웹 검색 완료 (1200ms)
```

#### 2.4 summary_paper.log (논문 요약)

```
2025-10-31 16:48:20 | 논문 요약 시작
2025-10-31 16:48:20 | 논문 ID: 123
2025-10-31 16:48:20 | 논문 제목: "Attention Is All You Need"
2025-10-31 16:48:20 | 논문 전문 로드 (10,234 tokens)
2025-10-31 16:48:20 | load_summarize_chain 실행
2025-10-31 16:48:22 | 초록 생성 완료 (350 tokens)
2025-10-31 16:48:22 | 논문 요약 완료 (2000ms)
```

#### 2.5 file_save.log (파일 저장)

```
2025-10-31 17:10:15 | 파일 저장 시작
2025-10-31 17:10:15 | 파일명: paper_summary_20251031_171015.txt
2025-10-31 17:10:15 | 내용 길이: 1,234 bytes
2025-10-31 17:10:15 | outputs/ 폴더에 저장
2025-10-31 17:10:15 | 파일 저장 완료
```

#### 2.6 general.log (일반 답변)

```
2025-10-31 18:20:30 | 일반 답변 생성 시작
2025-10-31 18:20:30 | 질문: "고마워"
2025-10-31 18:20:30 | 질문 유형: greeting
2025-10-31 18:20:30 | LLM 호출 (간단 답변 모드)
2025-10-31 18:20:31 | 답변 생성 완료
2025-10-31 18:20:31 | 일반 답변 완료 (500ms)
```

---

### 3. database/ 폴더

**목적**: 데이터베이스 쿼리 및 검색 결과 기록

#### 3.1 queries.sql

**모든 SQL 쿼리를 시간순으로 기록**

```sql
-- 실행 시간: 2025-10-31 10:30:25
-- 도구: rag_paper
-- 설명: pgvector 유사도 검색

SELECT paper_id, chunk_text, embedding <=> '[0.123, 0.456, ...]' AS distance
FROM paper_chunks
ORDER BY distance
LIMIT 5;

-- 실행 시간: 2025-10-31 10:30:25
-- 도구: rag_paper
-- 설명: 논문 메타데이터 조회

SELECT paper_id, title, authors, publish_date, source, url, category, abstract
FROM papers
WHERE paper_id IN (123, 456, 789, 234, 567);

-- 실행 시간: 2025-10-31 10:30:26
-- 도구: rag_glossary
-- 설명: 용어집 조회

SELECT term_id, term, definition, easy_explanation, hard_explanation
FROM glossary
WHERE term = 'Attention Mechanism';

-- 실행 시간: 2025-10-31 10:30:27
-- 도구: system
-- 설명: query_logs 테이블에 실행 로그 저장

INSERT INTO query_logs
(user_query, difficulty_mode, tool_used, response, response_time_ms, success)
VALUES
('RAG에 대해 알려줘', 'easy', 'rag_paper', '답변 내용...', 2500, TRUE);
```

#### 3.2 pgvector_searches.json

**pgvector 벡터 검색 상세 기록**

```json
[
  {
    "timestamp": "2025-10-31T10:30:25",
    "tool": "rag_paper",
    "collection": "paper_chunks",
    "query_text": "RAG에 대해 알려줘",
    "query_embedding_preview": "[0.123, 0.456, 0.789, ...]",
    "embedding_dimension": 1536,
    "embedding_model": "text-embedding-3-small",
    "search_type": "similarity",
    "similarity_metric": "cosine",
    "top_k": 5,
    "execution_time_ms": 45,
    "results_preview": [
      {
        "chunk_id": 1234,
        "paper_id": 123,
        "distance": 0.15,
        "chunk_preview": "RAG는 외부 지식을 검색하여..."
      },
      {
        "chunk_id": 5678,
        "paper_id": 456,
        "distance": 0.23,
        "chunk_preview": "Dense Passage Retrieval은..."
      }
    ]
  },
  {
    "timestamp": "2025-10-31T10:30:26",
    "tool": "rag_glossary",
    "collection": "glossary_embeddings",
    "query_text": "Attention Mechanism",
    "embedding_dimension": 1536,
    "search_type": "mmr",
    "similarity_metric": "cosine",
    "top_k": 3,
    "lambda_mult": 0.5,
    "execution_time_ms": 32
  }
]
```

#### 3.3 search_results.json

**DB 검색 결과 상세 정보**

```json
{
  "rag_paper": {
    "timestamp": "2025-10-31T10:30:25",
    "query": "RAG에 대해 알려줘",
    "difficulty": "easy",
    "results_count": 5,
    "papers": [
      {
        "paper_id": 123,
        "title": "Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks",
        "authors": "Patrick Lewis, Ethan Perez, Aleksandara Piktus, Fabio Petroni, ...",
        "publish_date": "2020-05-22",
        "source": "arXiv",
        "url": "https://arxiv.org/abs/2005.11401",
        "category": "cs.CL",
        "relevance_score": 0.92,
        "chunk_text": "RAG는 외부 지식을 검색하여 생성 모델에 통합하는 기법입니다. 사전 학습된 parametric memory와 non-parametric memory를 결합합니다...",
        "chunk_position": "abstract"
      },
      {
        "paper_id": 456,
        "title": "Dense Passage Retrieval for Open-Domain Question Answering",
        "authors": "Vladimir Karpukhin, Barlas Oguz, Sewon Min, ...",
        "publish_date": "2020-04-10",
        "source": "arXiv",
        "url": "https://arxiv.org/abs/2004.04906",
        "category": "cs.CL",
        "relevance_score": 0.87,
        "chunk_text": "DPR은 밀집 벡터 표현을 사용하여 관련 문서를 검색합니다..."
      },
      {
        "paper_id": 789,
        "title": "REALM: Retrieval-Augmented Language Model Pre-Training",
        "relevance_score": 0.83
      },
      {
        "paper_id": 234,
        "title": "Leveraging Passage Retrieval with Generative Models",
        "relevance_score": 0.78
      },
      {
        "paper_id": 567,
        "title": "FiD: Fusion-in-Decoder for Open-Domain Question Answering",
        "relevance_score": 0.75
      }
    ],
    "total_chunks_scanned": 10000,
    "search_time_ms": 45
  },
  "rag_glossary": {
    "timestamp": "2025-10-31T10:30:26",
    "query": "Attention Mechanism",
    "difficulty": "easy",
    "results_count": 1,
    "terms": [
      {
        "term_id": 42,
        "term": "Attention Mechanism",
        "difficulty_mode": "easy",
        "explanation": "책을 읽을 때 중요한 부분에 집중하는 것처럼, AI가 입력 데이터에서 중요한 부분에 집중하는 기술입니다. 예를 들어, '나는 학교에 간다'라는 문장에서 '학교'가 중요하다고 판단하면 그 단어에 더 많은 주의를 기울입니다.",
        "category": "Deep Learning",
        "difficulty_level": "intermediate",
        "related_terms": ["Transformer", "Self-Attention", "Multi-Head Attention"]
      }
    ],
    "search_time_ms": 8
  }
}
```

#### 3.4 db_performance.json

**데이터베이스 성능 분석**

```json
{
  "summary": {
    "total_queries": 4,
    "total_execution_time_ms": 120,
    "avg_query_time_ms": 30,
    "slowest_query_ms": 45,
    "fastest_query_ms": 5
  },
  "queries": [
    {
      "query_id": 1,
      "query_type": "pgvector_similarity",
      "collection": "paper_chunks",
      "execution_time_ms": 45,
      "rows_scanned": 10000,
      "rows_returned": 5,
      "index_used": "paper_chunks_embedding_idx"
    },
    {
      "query_id": 2,
      "query_type": "select",
      "table": "papers",
      "execution_time_ms": 12,
      "rows_scanned": 5,
      "rows_returned": 5,
      "index_used": "papers_pkey"
    },
    {
      "query_id": 3,
      "query_type": "select",
      "table": "glossary",
      "execution_time_ms": 8,
      "rows_scanned": 1,
      "rows_returned": 1,
      "index_used": "idx_glossary_term"
    },
    {
      "query_id": 4,
      "query_type": "insert",
      "table": "query_logs",
      "execution_time_ms": 5,
      "rows_affected": 1,
      "success": true
    }
  ],
  "connection_info": {
    "host": "localhost",
    "port": 5432,
    "database": "papers",
    "pool_size": 10,
    "active_connections": 1
  },
  "tables_accessed": ["paper_chunks", "papers", "glossary", "query_logs"],
  "indexes_used": ["paper_chunks_embedding_idx", "papers_pkey", "idx_glossary_term"]
}
```

---

### 4. prompts/ 폴더

**목적**: LLM에 전달된 프롬프트 기록 (재현성 확보)

#### 4.1 system_prompt.txt

```
당신은 논문을 쉽게 설명하는 전문가입니다.

[역할]
- 초보자도 이해할 수 있도록 쉬운 용어 사용
- 비유와 예시를 많이 활용
- 전문 용어는 풀어서 설명
- 한글로 친절하게 답변

[답변 규칙]
1. 초등학생도 이해할 수 있는 수준으로 설명
2. "즉", "예를 들어" 등의 연결어 사용
3. 한 문장을 짧게 (20자 이내)
4. 불필요한 전문 용어 배제

===== 메타데이터 =====
난이도: easy
생성 시간: 2025-10-31T10:30:25
템플릿: EASY_SYSTEM_PROMPT
모델: gpt-4
Temperature: 0.7
```

#### 4.2 user_prompt.txt

```
[참고 논문]

1. Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks
   저자: Patrick Lewis, Ethan Perez, et al.
   연도: 2020
   출처: arXiv:2005.11401

   내용: RAG는 외부 지식을 검색하여 생성 모델에 통합하는 기법입니다.
   사전 학습된 parametric memory (모델 파라미터)와 non-parametric memory
   (외부 문서 인덱스)를 결합합니다. 이를 통해 지식 집약적인 NLP 태스크에서
   강력한 성능을 발휘합니다...

2. Dense Passage Retrieval for Open-Domain Question Answering
   저자: Vladimir Karpukhin, Barlas Oguz, et al.
   연도: 2020
   출처: arXiv:2004.04906

   내용: DPR은 밀집 벡터 표현을 사용하여 관련 문서를 검색합니다.
   질문과 문서를 각각 독립적으로 인코딩하고, 내적을 통해 유사도를 계산합니다...

3. REALM: Retrieval-Augmented Language Model Pre-Training
   ...

[질문]
RAG에 대해 알려줘

위 논문을 참고하여 초보자가 이해하기 쉽게 답변해주세요.

===== 메타데이터 =====
검색 결과 수: 5개 논문
컨텍스트 총 길이: 1,234 tokens
생성 시간: 2025-10-31T10:30:25
검색 도구: rag_paper
검색 시간: 45ms
```

#### 4.3 final_prompt.txt

```
===== SYSTEM =====
당신은 논문을 쉽게 설명하는 전문가입니다.

[역할]
- 초보자도 이해할 수 있도록 쉬운 용어 사용
- 비유와 예시를 많이 활용
- 전문 용어는 풀어서 설명
- 한글로 친절하게 답변

[답변 규칙]
1. 초등학생도 이해할 수 있는 수준으로 설명
2. "즉", "예를 들어" 등의 연결어 사용
3. 한 문장을 짧게 (20자 이내)
4. 불필요한 전문 용어 배제

===== USER =====
[참고 논문]

1. Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks
   저자: Patrick Lewis, Ethan Perez, et al.
   연도: 2020
   ...

[질문]
RAG에 대해 알려줘

위 논문을 참고하여 초보자가 이해하기 쉽게 답변해주세요.

===== 메타데이터 =====
총 토큰 수: 2,345 tokens (system: 234, user: 2,111)
모델: gpt-4
Temperature: 0.7
Max Tokens: 2000
Streaming: true
생성 시간: 2025-10-31T10:30:25
```

#### 4.4 prompt_template.yaml

```yaml
# 프롬프트 템플릿 정보

difficulty: easy
template_name: EASY_SYSTEM_PROMPT
template_version: 1.0

variables:
  context: |
    [참고 논문]
    1. Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks
    ...
  question: "RAG에 대해 알려줘"

llm_config:
  provider: openai
  model: gpt-4
  temperature: 0.7
  max_tokens: 2000
  streaming: true
  top_p: 1.0
  frequency_penalty: 0.0
  presence_penalty: 0.0

token_count:
  system_prompt: 234
  user_prompt: 2111
  total_input: 2345
  max_output: 2000

prompt_chain:
  - step: 1
    type: system_prompt
    template: EASY_SYSTEM_PROMPT
  - step: 2
    type: user_prompt
    template: RAG_USER_TEMPLATE
  - step: 3
    type: context_injection
    source: rag_paper
    context_length: 1234

metadata:
  created_at: "2025-10-31T10:30:25"
  difficulty: easy
  tool_used: rag_paper
  search_results_count: 5
```

---

### 5. ui/ 폴더

**목적**: Streamlit UI 인터랙션 및 세션 정보 기록

#### 5.1 streamlit_session.json

```json
{
  "session_id": "abc123def456",
  "start_time": "2025-10-31T10:30:15",
  "end_time": "2025-10-31T10:32:45",
  "duration_seconds": 150,
  "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
  "ip_address": "127.0.0.1",
  "browser": "Chrome",
  "os": "Windows 10",
  "screen_resolution": "1920x1080",
  "session_state": {
    "messages": [
      {
        "role": "user",
        "content": "RAG에 대해 알려줘",
        "timestamp": "2025-10-31T10:30:20",
        "length": 12
      },
      {
        "role": "assistant",
        "content": "RAG는 검색 증강 생성이라는 뜻입니다. 쉽게 말하면, AI가 답변할 때 인터넷이나 데이터베이스에서 관련 정보를 먼저 찾아보고 그 정보를 바탕으로 답변하는 방식입니다...",
        "timestamp": "2025-10-31T10:30:25",
        "length": 450,
        "tool_used": "rag_paper"
      }
    ],
    "difficulty": "easy",
    "conversation_turns": 1,
    "widgets": {
      "difficulty_selector": "easy",
      "chat_input": "RAG에 대해 알려줘"
    }
  },
  "page_views": [
    {
      "timestamp": "2025-10-31T10:30:15",
      "page": "main"
    }
  ]
}
```

#### 5.2 user_interactions.log

```
2025-10-31 10:30:15 | 페이지 접속
2025-10-31 10:30:16 | 사이드바 열기
2025-10-31 10:30:17 | 난이도 선택 버튼 클릭: easy
2025-10-31 10:30:18 | 안내 문구 확인 (info box 표시)
2025-10-31 10:30:20 | 질문 입력 필드 포커스
2025-10-31 10:30:20 | 질문 입력 시작
2025-10-31 10:30:20 | 질문 입력 완료: "RAG에 대해 알려줘" (12자)
2025-10-31 10:30:20 | 질문 제출 버튼 클릭 (Enter 키)
2025-10-31 10:30:20 | 로딩 스피너 표시
2025-10-31 10:30:20 | StreamlitCallbackHandler 활성화
2025-10-31 10:30:21 | Agent 실행 중 표시: "도구 선택 중..."
2025-10-31 10:30:22 | Agent 실행 중 표시: "논문 검색 중..."
2025-10-31 10:30:23 | Agent 실행 중 표시: "답변 생성 중..."
2025-10-31 10:30:25 | 로딩 스피너 제거
2025-10-31 10:30:25 | 답변 렌더링 시작
2025-10-31 10:30:25 | 답변 렌더링 완료 (450자)
2025-10-31 10:30:25 | 출처 expander 표시
2025-10-31 10:30:27 | 스크롤 다운 (100px)
2025-10-31 10:30:28 | 출처 expander 클릭 (확장)
2025-10-31 10:30:30 | 출처 expander 클릭 (축소)
2025-10-31 10:30:32 | 페이지 종료
```

#### 5.3 ui_events.json

```json
[
  {
    "timestamp": "2025-10-31T10:30:15",
    "event_type": "page_load",
    "page": "main",
    "load_time_ms": 234
  },
  {
    "timestamp": "2025-10-31T10:30:16",
    "event_type": "sidebar_toggled",
    "state": "open"
  },
  {
    "timestamp": "2025-10-31T10:30:17",
    "event_type": "difficulty_changed",
    "old_value": null,
    "new_value": "easy"
  },
  {
    "timestamp": "2025-10-31T10:30:20",
    "event_type": "input_focused",
    "widget": "chat_input"
  },
  {
    "timestamp": "2025-10-31T10:30:20",
    "event_type": "message_submitted",
    "message_length": 12,
    "message_preview": "RAG에 대해 알려...",
    "submission_method": "enter_key"
  },
  {
    "timestamp": "2025-10-31T10:30:20",
    "event_type": "agent_started",
    "difficulty": "easy"
  },
  {
    "timestamp": "2025-10-31T10:30:25",
    "event_type": "response_received",
    "response_length": 450,
    "response_time_ms": 5000,
    "tool_used": "rag_paper"
  },
  {
    "timestamp": "2025-10-31T10:30:25",
    "event_type": "response_rendered",
    "streaming": true,
    "render_time_ms": 120
  },
  {
    "timestamp": "2025-10-31T10:30:28",
    "event_type": "expander_toggled",
    "expander_label": "참고 논문",
    "state": "expanded"
  },
  {
    "timestamp": "2025-10-31T10:30:30",
    "event_type": "expander_toggled",
    "expander_label": "참고 논문",
    "state": "collapsed"
  },
  {
    "timestamp": "2025-10-31T10:30:32",
    "event_type": "session_ended",
    "total_duration_seconds": 17,
    "total_messages": 2
  }
]
```

---

### 6. outputs/ 폴더

**목적**: 사용자에게 제공되는 최종 결과물 저장

#### 6.1 response.txt

```
RAG는 검색 증강 생성이라는 뜻입니다. 쉽게 말하면, AI가 답변할 때 인터넷이나 데이터베이스에서 관련 정보를 먼저 찾아보고 그 정보를 바탕으로 답변하는 방식입니다.

예를 들어, 선생님께 질문을 하면 선생님이 책을 펴서 확인한 후 답변해주시는 것과 비슷합니다. AI도 마찬가지로 자신의 기억(학습된 지식)만으로 답하는 것이 아니라, 외부 자료를 찾아서 더 정확하고 최신의 답변을 제공합니다.

RAG의 장점은:
1. 더 정확한 답변: 실제 자료를 참고하므로 틀린 정보를 줄 확률이 낮습니다
2. 최신 정보: AI가 학습하지 않은 최신 정보도 검색해서 답변할 수 있습니다
3. 출처 제공: 어떤 자료를 참고했는지 알려줄 수 있습니다

이 기술은 논문 검색, 고객 지원, 의료 정보 제공 등 다양한 분야에서 활용되고 있습니다.

===== 참고 논문 =====
1. Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks (Patrick Lewis et al., 2020)
2. Dense Passage Retrieval for Open-Domain Question Answering (Vladimir Karpukhin et al., 2020)
3. REALM: Retrieval-Augmented Language Model Pre-Training (Kelvin Guu et al., 2020)
```

#### 6.2 summary.md (논문 요약 시)

```markdown
# 논문 요약: Attention Is All You Need

## 기본 정보
- **제목**: Attention Is All You Need
- **저자**: Ashish Vaswani, Noam Shazeer, et al.
- **발표**: 2017년 NIPS
- **출처**: arXiv:1706.03762

## 핵심 내용

### 1. 연구 배경
기존 sequence-to-sequence 모델은 RNN이나 CNN을 사용했습니다. 하지만 이런 모델들은 긴 문장을 처리할 때 느리고 병렬 처리가 어렵다는 문제가 있었습니다.

### 2. 제안 방법
이 논문은 **Transformer**라는 새로운 모델을 제안합니다. RNN이나 CNN 없이 오직 Attention 메커니즘만 사용합니다.

### 3. 주요 특징
- Self-Attention: 문장 내 단어들 간의 관계를 파악
- Multi-Head Attention: 여러 관점에서 동시에 Attention 계산
- Positional Encoding: 단어의 순서 정보 제공

### 4. 실험 결과
- 번역 품질: 기존 최고 성능을 뛰어넘음
- 학습 속도: 기존 모델보다 훨씬 빠름

## 의의
Transformer는 이후 BERT, GPT 등 현대 AI 모델의 기반이 되었습니다.
```

#### 6.3 saved_file.txt (사용자 저장 요청)

```
[사용자가 "파일로 저장해줘" 요청 시 생성된 파일]

RAG에 대한 설명

RAG는 검색 증강 생성(Retrieval-Augmented Generation)의 약자입니다...

[전체 답변 내용]

생성 일시: 2025-10-31 10:30:25
난이도: Easy
```

---

### 7. evaluation/ 폴더

**목적**: RAG, Agent, DB 성능 평가 지표 기록 (PRD 09_평가_기준 참고)

**특징**:
- 성능 평가 및 모니터링을 위한 정량적 지표 수집
- 실험 결과 비교 분석 가능
- 목표 지표 달성 여부 추적

#### 7.1 rag_metrics.json

**RAG 검색 품질 평가 지표**

```json
{
  "timestamp": "2025-10-31T10:30:25",
  "session_id": "001",
  "user_query": "RAG에 대해 알려줘",
  "difficulty": "easy",
  "tool_used": "rag_paper",

  "retrieval_metrics": {
    "recall_at_1": 1.0,
    "recall_at_3": 1.0,
    "recall_at_5": 0.8,
    "precision_at_1": 1.0,
    "precision_at_3": 0.67,
    "precision_at_5": 0.4,
    "mrr": 1.0,
    "map": 0.85,
    "ndcg_at_5": 0.92
  },

  "generation_metrics": {
    "faithfulness": 0.95,
    "answer_relevancy": 0.88,
    "context_precision": 0.90,
    "context_recall": 0.85,
    "context_relevancy": 0.92
  },

  "answer_quality": {
    "em_score": 0.0,
    "f1_score": 0.78,
    "bleu_score": 0.45,
    "rouge_l": 0.72
  },

  "retrieved_documents": {
    "total_retrieved": 5,
    "relevant_retrieved": 4,
    "total_relevant": 5,
    "irrelevant_retrieved": 1
  },

  "target_comparison": {
    "recall_at_5_target": 0.6,
    "recall_at_5_actual": 0.8,
    "recall_at_5_status": "PASS",
    "faithfulness_target": 0.9,
    "faithfulness_actual": 0.95,
    "faithfulness_status": "PASS"
  },

  "notes": "RAG 검색 품질이 목표치를 상회함. Precision은 낮지만 Recall이 높아 충분한 관련 문서 검색"
}
```

#### 7.2 agent_accuracy.json

**AI Agent 도구 선택 정확도**

```json
{
  "timestamp": "2025-10-31T10:30:25",
  "session_id": "001",
  "user_query": "RAG에 대해 알려줘",
  "difficulty": "easy",

  "routing_decision": {
    "predicted_tool": "rag_paper",
    "expected_tool": "rag_paper",
    "correct": true,
    "confidence": 0.98,
    "routing_time_ms": 200
  },

  "tool_selection_breakdown": {
    "rag_paper": 0.98,
    "rag_glossary": 0.01,
    "web_search": 0.005,
    "summary_paper": 0.003,
    "file_save": 0.001,
    "general": 0.001
  },

  "agent_performance": {
    "total_steps": 3,
    "successful_steps": 3,
    "failed_steps": 0,
    "retry_count": 0,
    "fallback_used": false
  },

  "execution_flow": [
    {
      "step": 1,
      "node": "router_node",
      "decision": "rag_paper",
      "execution_time_ms": 200,
      "success": true
    },
    {
      "step": 2,
      "node": "rag_paper_node",
      "execution_time_ms": 2800,
      "success": true
    },
    {
      "step": 3,
      "node": "generate_answer_node",
      "execution_time_ms": 2000,
      "success": true
    }
  ],

  "target_comparison": {
    "routing_accuracy_target": 0.9,
    "routing_accuracy_actual": 1.0,
    "routing_accuracy_status": "PASS"
  },

  "notes": "Agent가 올바른 도구를 높은 신뢰도로 선택함"
}
```

#### 7.3 latency_report.json

**응답 시간 분석 (p50, p95, p99)**

```json
{
  "timestamp": "2025-10-31T10:30:25",
  "session_id": "001",
  "difficulty": "easy",
  "tool_used": "rag_paper",

  "total_latency": {
    "total_time_ms": 5000,
    "target_p95_ms": 6000,
    "status": "PASS"
  },

  "breakdown": {
    "routing_time_ms": 200,
    "routing_percentage": 4.0,

    "retrieval_time_ms": 2800,
    "retrieval_percentage": 56.0,
    "retrieval_breakdown": {
      "embedding_generation_ms": 100,
      "pgvector_search_ms": 45,
      "db_metadata_query_ms": 12,
      "context_preparation_ms": 2643
    },

    "generation_time_ms": 2000,
    "generation_percentage": 40.0,
    "generation_breakdown": {
      "llm_call_ms": 1850,
      "prompt_formatting_ms": 80,
      "response_formatting_ms": 70
    }
  },

  "database_latency": {
    "pgvector_search_ms": 45,
    "papers_table_query_ms": 12,
    "glossary_table_query_ms": 0,
    "query_logs_insert_ms": 5,
    "total_db_time_ms": 62
  },

  "llm_latency": {
    "model": "gpt-4",
    "prompt_tokens": 1468,
    "completion_tokens": 877,
    "total_tokens": 2345,
    "time_ms": 1850,
    "tokens_per_second": 1267
  },

  "percentiles": {
    "p50": 5000,
    "p95": 5000,
    "p99": 5000,
    "note": "단일 쿼리이므로 모든 percentile 동일"
  },

  "bottleneck_analysis": {
    "slowest_component": "retrieval",
    "slowest_time_ms": 2800,
    "optimization_suggestions": [
      "context_preparation 시간 최적화 필요",
      "pgvector 인덱스 튜닝 고려"
    ]
  },

  "target_comparison": {
    "total_target_p95_ms": 6000,
    "total_actual_ms": 5000,
    "total_status": "PASS",
    "db_target_p95_ms": 100,
    "db_actual_ms": 62,
    "db_status": "PASS",
    "llm_target_p95_ms": 3000,
    "llm_actual_ms": 1850,
    "llm_status": "PASS"
  }
}
```

#### 7.4 cost_analysis.json

**토큰 사용량 및 비용 분석**

```json
{
  "timestamp": "2025-10-31T10:30:25",
  "session_id": "001",
  "user_query": "RAG에 대해 알려줘",
  "difficulty": "easy",
  "tool_used": "rag_paper",

  "llm_usage": {
    "model": "gpt-4",
    "prompt_tokens": 1468,
    "completion_tokens": 877,
    "total_tokens": 2345,
    "streaming": true
  },

  "embedding_usage": {
    "model": "text-embedding-3-small",
    "total_embeddings": 1,
    "total_tokens": 12,
    "dimensions": 1536
  },

  "cost_breakdown_usd": {
    "gpt4_input_cost": 0.01468,
    "gpt4_output_cost": 0.00877,
    "gpt4_total_cost": 0.02345,

    "embedding_cost": 0.0000024,

    "total_cost": 0.0234524,

    "pricing": {
      "gpt4_input_per_1k": 0.01,
      "gpt4_output_per_1k": 0.01,
      "embedding_per_1k": 0.0002
    }
  },

  "cost_breakdown_krw": {
    "gpt4_input_cost": 19.11,
    "gpt4_output_cost": 11.40,
    "gpt4_total_cost": 30.51,

    "embedding_cost": 0.003,

    "total_cost": 30.51,

    "exchange_rate": 1300
  },

  "session_statistics": {
    "total_queries": 1,
    "total_cost_usd": 0.0234524,
    "avg_cost_per_query_usd": 0.0234524,
    "total_cost_krw": 30.51,
    "avg_cost_per_query_krw": 30.51
  },

  "budget_tracking": {
    "daily_budget_krw": 10000,
    "used_so_far_krw": 30.51,
    "remaining_krw": 9969.49,
    "budget_status": "SAFE"
  },

  "optimization_suggestions": [
    "현재 GPT-4 사용 중. 개발 단계에서는 GPT-3.5-turbo 사용 권장 (비용 1/10)",
    "프롬프트 길이 최적화로 input token 절감 가능"
  ]
}
```

#### 7.5 test_results.json

**테스트 시나리오 결과**

```json
{
  "timestamp": "2025-10-31T10:30:25",
  "test_suite": "rag_basic_test",
  "total_tests": 10,
  "passed": 9,
  "failed": 1,
  "success_rate": 0.9,

  "test_cases": [
    {
      "test_id": 1,
      "test_name": "rag_paper_retrieval_basic",
      "query": "RAG에 대해 알려줘",
      "expected_tool": "rag_paper",
      "actual_tool": "rag_paper",
      "expected_papers_count": 5,
      "actual_papers_count": 5,
      "recall_at_5": 0.8,
      "faithfulness": 0.95,
      "response_time_ms": 5000,
      "status": "PASS",
      "notes": "모든 지표가 목표치 달성"
    },
    {
      "test_id": 2,
      "test_name": "glossary_easy_mode",
      "query": "Attention Mechanism이 뭐야?",
      "expected_tool": "rag_glossary",
      "actual_tool": "rag_glossary",
      "expected_difficulty": "easy",
      "actual_difficulty": "easy",
      "term_found": true,
      "response_time_ms": 800,
      "status": "PASS",
      "notes": "용어집 검색 정상 동작"
    },
    {
      "test_id": 3,
      "test_name": "web_search_latest_info",
      "query": "2024년 최신 Transformer 논문",
      "expected_tool": "web_search",
      "actual_tool": "rag_paper",
      "search_results_count": 0,
      "response_time_ms": 4500,
      "status": "FAIL",
      "notes": "웹 검색 대신 RAG 검색 선택됨. 라우팅 로직 개선 필요"
    },
    {
      "test_id": 4,
      "test_name": "paper_summary_request",
      "query": "Attention Is All You Need 논문 요약해줘",
      "expected_tool": "summary_paper",
      "actual_tool": "summary_paper",
      "summary_generated": true,
      "summary_length_tokens": 350,
      "response_time_ms": 6500,
      "status": "PASS",
      "notes": "논문 요약 성공"
    },
    {
      "test_id": 5,
      "test_name": "file_save_request",
      "query": "위 내용 파일로 저장해줘",
      "expected_tool": "file_save",
      "actual_tool": "file_save",
      "file_created": true,
      "file_size_bytes": 1234,
      "response_time_ms": 300,
      "status": "PASS",
      "notes": "파일 저장 성공"
    },
    {
      "test_id": 6,
      "test_name": "general_greeting",
      "query": "안녕하세요",
      "expected_tool": "general",
      "actual_tool": "general",
      "response_appropriate": true,
      "response_time_ms": 500,
      "status": "PASS",
      "notes": "일반 인사 처리 정상"
    },
    {
      "test_id": 7,
      "test_name": "difficulty_switching_easy",
      "query": "Transformer 설명해줘",
      "difficulty": "easy",
      "explanation_level": "초등학생 수준",
      "jargon_count": 2,
      "analogy_count": 3,
      "status": "PASS",
      "notes": "Easy 모드 설명 적절"
    },
    {
      "test_id": 8,
      "test_name": "difficulty_switching_hard",
      "query": "Transformer 설명해줘",
      "difficulty": "hard",
      "explanation_level": "전문가 수준",
      "jargon_count": 15,
      "technical_depth": "high",
      "status": "PASS",
      "notes": "Hard 모드 설명 적절"
    },
    {
      "test_id": 9,
      "test_name": "context_length_limit",
      "query": "RAG, DPR, REALM, FiD 모두 설명해줘",
      "expected_papers_count": 20,
      "actual_papers_count": 5,
      "context_tokens": 2111,
      "max_context_tokens": 4000,
      "status": "PASS",
      "notes": "컨텍스트 길이 제한 내에서 처리"
    },
    {
      "test_id": 10,
      "test_name": "error_handling_invalid_query",
      "query": "",
      "expected_error": "empty_query",
      "actual_error": "empty_query",
      "error_handled": true,
      "status": "PASS",
      "notes": "빈 쿼리 에러 처리 정상"
    }
  ],

  "aggregate_metrics": {
    "avg_response_time_ms": 2890,
    "avg_recall_at_5": 0.8,
    "avg_faithfulness": 0.95,
    "agent_routing_accuracy": 0.9,
    "total_cost_usd": 0.234,
    "total_cost_krw": 304.2
  },

  "target_comparison": {
    "success_rate_target": 0.95,
    "success_rate_actual": 0.9,
    "success_rate_status": "NEAR_PASS",
    "p95_latency_target_ms": 6000,
    "p95_latency_actual_ms": 6500,
    "p95_latency_status": "NEAR_PASS"
  },

  "failed_tests_summary": [
    {
      "test_id": 3,
      "test_name": "web_search_latest_info",
      "reason": "Agent가 웹 검색 대신 RAG 검색 선택",
      "action_required": "라우팅 로직에 날짜 키워드 감지 추가"
    }
  ]
}
```

---

### 8. debug/ 폴더

**목적**: 개발 및 디버깅을 위한 상세 정보 (선택 사항)

#### 8.1 agent_trace.json

```json
{
  "agent_execution": {
    "start_time": "2025-10-31T10:30:20",
    "end_time": "2025-10-31T10:30:25",
    "total_time_ms": 5000,
    "graph_executions": [
      {
        "step": 1,
        "node": "router_node",
        "input": {
          "question": "RAG에 대해 알려줘",
          "difficulty": "easy"
        },
        "output": {
          "tool_choice": "rag_paper"
        },
        "execution_time_ms": 200
      },
      {
        "step": 2,
        "node": "rag_paper_node",
        "input": {
          "question": "RAG에 대해 알려줘",
          "difficulty": "easy"
        },
        "output": {
          "context": "[논문 컨텍스트...]",
          "papers_count": 5
        },
        "execution_time_ms": 2800
      },
      {
        "step": 3,
        "node": "generate_answer_node",
        "input": {
          "question": "RAG에 대해 알려줘",
          "context": "[논문 컨텍스트...]",
          "difficulty": "easy"
        },
        "output": {
          "final_answer": "RAG는 검색 증강 생성...",
          "answer_length": 450
        },
        "execution_time_ms": 2000
      }
    ],
    "conditional_edges": [
      {
        "from": "router_node",
        "to": "rag_paper_node",
        "condition": "tool_choice == 'rag_paper'"
      },
      {
        "from": "rag_paper_node",
        "to": "generate_answer_node",
        "condition": "context_available == True"
      }
    ]
  }
}
```

#### 8.2 llm_tokens.json

```json
{
  "total_tokens": 2345,
  "total_cost_usd": 0.0234,
  "calls": [
    {
      "call_id": 1,
      "timestamp": "2025-10-31T10:30:23",
      "model": "gpt-4",
      "purpose": "generate_answer",
      "prompt_tokens": 1468,
      "completion_tokens": 877,
      "total_tokens": 2345,
      "cost_usd": 0.0234,
      "execution_time_ms": 2000,
      "temperature": 0.7,
      "max_tokens": 2000,
      "streaming": true
    }
  ],
  "token_breakdown": {
    "system_prompt": 234,
    "user_prompt": 2111,
    "context": 1234,
    "question": 12,
    "completion": 877
  },
  "cost_breakdown": {
    "input_cost": 0.0147,
    "output_cost": 0.0087,
    "total_cost": 0.0234
  }
}
```

#### 8.3 error_trace.log

```
2025-10-31 15:30:25 | [ERROR] pgvector 연결 실패
2025-10-31 15:30:25 | Traceback (most recent call last):
2025-10-31 15:30:25 |   File "src/agent/tools/rag_paper.py", line 45, in search_paper_database
2025-10-31 15:30:25 |     results = vectorstore.similarity_search(query, k=5)
2025-10-31 15:30:25 |   File "langchain_postgres/vectorstores.py", line 234, in similarity_search
2025-10-31 15:30:25 |     conn = psycopg2.connect(self.connection_string)
2025-10-31 15:30:25 | psycopg2.OperationalError: could not connect to server
2025-10-31 15:30:25 |
2025-10-31 15:30:25 | [RESOLUTION] Retry 1/3: Attempting reconnection...
2025-10-31 15:30:27 | [SUCCESS] Connection established
```

---

## ExperimentManager 구현

**파일 경로**: `src/utils/experiment_manager.py`

```python
import json
import yaml
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional
from src.utils.logger import Logger


class ExperimentManager:
    """
    실험 폴더 생성 및 관리 클래스

    DB, UI, 프롬프트 등 모든 정보를 체계적으로 기록
    """

    def __init__(self):
        """실험 매니저 초기화"""
        today = datetime.now().strftime("%Y%m%d")
        time_now = datetime.now().strftime("%H%M%S")

        # 당일 session ID 생성
        session_id = self._get_next_session_id(today)

        # 메인 폴더
        self.experiment_dir = Path(
            f"experiments/{today}/{today}_{time_now}_session_{session_id:03d}"
        )
        self.experiment_dir.mkdir(parents=True, exist_ok=True)

        # 서브 폴더 생성
        self.tools_dir = self.experiment_dir / "tools"
        self.database_dir = self.experiment_dir / "database"
        self.prompts_dir = self.experiment_dir / "prompts"
        self.ui_dir = self.experiment_dir / "ui"
        self.outputs_dir = self.experiment_dir / "outputs"
        self.evaluation_dir = self.experiment_dir / "evaluation"
        self.debug_dir = self.experiment_dir / "debug"

        # 필수 폴더 생성
        for folder in [self.tools_dir, self.database_dir, self.prompts_dir,
                       self.ui_dir, self.outputs_dir, self.evaluation_dir]:
            folder.mkdir(exist_ok=True)

        # 메타데이터 초기화
        self.metadata = {
            'session_id': f"{session_id:03d}",
            'start_time': datetime.now().isoformat(),
            'difficulty': None,
            'tool_used': None,
            'user_query': None,
            'success': None,
            'response_time_ms': None,
            'end_time': None
        }

        self.metadata_file = self.experiment_dir / "metadata.json"

        # Logger 초기화
        self.logger = Logger(str(self.experiment_dir / "chatbot.log"))
        self.logger.write(f"세션 시작: session_{session_id:03d}")
        self.logger.write(f"폴더 경로: {self.experiment_dir}")

        # DB 관련 초기화
        self.db_queries = []
        self.pgvector_searches = []
        self.search_results = {}
        self.db_performance = {
            'summary': {},
            'queries': []
        }

    def _get_next_session_id(self, date: str) -> int:
        """당일 다음 session ID 반환"""
        date_dir = Path(f"experiments/{date}")
        if not date_dir.exists():
            return 1

        existing_sessions = list(date_dir.glob(f"{date}_*_session_*"))
        if not existing_sessions:
            return 1

        max_id = 0
        for session_dir in existing_sessions:
            try:
                session_id_str = session_dir.name.split('_')[-1]
                session_id = int(session_id_str)
                max_id = max(max_id, session_id)
            except (IndexError, ValueError):
                continue

        return max_id + 1

    # ===== 도구 로그 =====

    def get_tool_logger(self, tool_name: str) -> Logger:
        """
        도구별 Logger 생성

        Args:
            tool_name: 도구명 (rag_paper, rag_glossary, web_search 등)

        Returns:
            Logger 인스턴스
        """
        log_path = self.tools_dir / f"{tool_name}.log"
        return Logger(str(log_path))

    # ===== DB 관련 =====

    def log_sql_query(
        self,
        query: str,
        description: str = "",
        tool: str = "",
        execution_time_ms: Optional[int] = None
    ):
        """
        SQL 쿼리 기록

        Args:
            query: SQL 쿼리문
            description: 쿼리 설명
            tool: 사용한 도구명
            execution_time_ms: 실행 시간 (밀리초)
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        query_record = f"""-- 실행 시간: {timestamp}
-- 도구: {tool}
-- 설명: {description}
"""
        if execution_time_ms:
            query_record += f"-- 실행 소요: {execution_time_ms}ms\n"

        query_record += f"\n{query};\n\n"

        self.db_queries.append(query_record)

        # queries.sql 파일에 즉시 추가
        with open(self.database_dir / "queries.sql", 'a', encoding='utf-8') as f:
            f.write(query_record)

        self.logger.write(f"SQL 쿼리 기록: {description}")

    def log_pgvector_search(self, search_info: Dict):
        """
        pgvector 검색 기록

        Args:
            search_info: 검색 정보 딕셔너리
                - tool: 도구명
                - collection: 컬렉션명
                - query_text: 검색 쿼리
                - top_k: 검색 결과 수
                - execution_time_ms: 실행 시간
                등
        """
        search_info['timestamp'] = datetime.now().isoformat()
        self.pgvector_searches.append(search_info)

        # pgvector_searches.json 업데이트
        with open(self.database_dir / "pgvector_searches.json", 'w', encoding='utf-8') as f:
            json.dump(self.pgvector_searches, f, ensure_ascii=False, indent=2)

        self.logger.write(f"pgvector 검색 기록: {search_info.get('tool', 'unknown')}")

    def save_search_results(self, tool_name: str, results: Dict):
        """
        DB 검색 결과 저장

        Args:
            tool_name: 도구명
            results: 검색 결과 딕셔너리
        """
        results['timestamp'] = datetime.now().isoformat()
        self.search_results[tool_name] = results

        # search_results.json 업데이트
        with open(self.database_dir / "search_results.json", 'w', encoding='utf-8') as f:
            json.dump(self.search_results, f, ensure_ascii=False, indent=2)

        self.logger.write(f"검색 결과 저장: {tool_name}")

    def save_db_performance(self, performance_data: Dict):
        """
        DB 성능 정보 저장

        Args:
            performance_data: 성능 데이터 딕셔너리
        """
        with open(self.database_dir / "db_performance.json", 'w', encoding='utf-8') as f:
            json.dump(performance_data, f, ensure_ascii=False, indent=2)

        self.logger.write("DB 성능 정보 저장 완료")

    # ===== 프롬프트 관련 =====

    def save_system_prompt(self, system_prompt: str, metadata: Optional[Dict] = None):
        """
        시스템 프롬프트 저장

        Args:
            system_prompt: 시스템 프롬프트 텍스트
            metadata: 메타데이터 딕셔너리
        """
        content = system_prompt

        if metadata:
            content += "\n\n===== 메타데이터 =====\n"
            for key, value in metadata.items():
                content += f"{key}: {value}\n"

        with open(self.prompts_dir / "system_prompt.txt", 'w', encoding='utf-8') as f:
            f.write(content)

        self.logger.write("시스템 프롬프트 저장 완료")

    def save_user_prompt(self, user_prompt: str, metadata: Optional[Dict] = None):
        """
        사용자 프롬프트 저장

        Args:
            user_prompt: 사용자 프롬프트 텍스트
            metadata: 메타데이터 딕셔너리
        """
        content = user_prompt

        if metadata:
            content += "\n\n===== 메타데이터 =====\n"
            for key, value in metadata.items():
                content += f"{key}: {value}\n"

        with open(self.prompts_dir / "user_prompt.txt", 'w', encoding='utf-8') as f:
            f.write(content)

        self.logger.write("사용자 프롬프트 저장 완료")

    def save_final_prompt(self, final_prompt: str, metadata: Optional[Dict] = None):
        """
        최종 프롬프트 저장

        Args:
            final_prompt: 최종 프롬프트 텍스트
            metadata: 메타데이터 딕셔너리
        """
        content = final_prompt

        if metadata:
            content += "\n\n===== 메타데이터 =====\n"
            for key, value in metadata.items():
                content += f"{key}: {value}\n"

        with open(self.prompts_dir / "final_prompt.txt", 'w', encoding='utf-8') as f:
            f.write(content)

        self.logger.write("최종 프롬프트 저장 완료")

    def save_prompt_template(self, template_info: Dict):
        """
        프롬프트 템플릿 정보 저장

        Args:
            template_info: 템플릿 정보 딕셔너리
        """
        with open(self.prompts_dir / "prompt_template.yaml", 'w', encoding='utf-8') as f:
            yaml.dump(template_info, f, allow_unicode=True, sort_keys=False)

        self.logger.write("프롬프트 템플릿 저장 완료")

    # ===== UI 관련 =====

    def save_streamlit_session(self, session_data: Dict):
        """
        Streamlit 세션 상태 저장

        Args:
            session_data: 세션 데이터 딕셔너리
        """
        with open(self.ui_dir / "streamlit_session.json", 'w', encoding='utf-8') as f:
            json.dump(session_data, f, ensure_ascii=False, indent=2)

        self.logger.write("Streamlit 세션 저장 완료")

    def log_ui_interaction(self, interaction: str):
        """
        UI 인터랙션 로그

        Args:
            interaction: 인터랙션 설명
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_line = f"{timestamp} | {interaction}\n"

        with open(self.ui_dir / "user_interactions.log", 'a', encoding='utf-8') as f:
            f.write(log_line)

    def log_ui_event(self, event: Dict):
        """
        UI 이벤트 기록

        Args:
            event: 이벤트 딕셔너리
        """
        event['timestamp'] = datetime.now().isoformat()

        # 기존 이벤트 읽기
        events_file = self.ui_dir / "ui_events.json"
        if events_file.exists():
            with open(events_file, 'r', encoding='utf-8') as f:
                events = json.load(f)
        else:
            events = []

        events.append(event)

        # 업데이트
        with open(events_file, 'w', encoding='utf-8') as f:
            json.dump(events, f, ensure_ascii=False, indent=2)

    # ===== 출력 관련 =====

    def save_output(self, filename: str, content: str):
        """
        결과물 저장

        Args:
            filename: 파일명
            content: 내용
        """
        output_path = self.outputs_dir / filename
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(content)

        self.logger.write(f"결과물 저장: {filename}")

    # ===== 평가 지표 관련 =====

    def save_rag_metrics(self, metrics: Dict):
        """
        RAG 평가 지표 저장

        Args:
            metrics: RAG 평가 지표 딕셔너리
        """
        metrics['timestamp'] = datetime.now().isoformat()

        with open(self.evaluation_dir / "rag_metrics.json", 'w', encoding='utf-8') as f:
            json.dump(metrics, f, ensure_ascii=False, indent=2)

        self.logger.write("RAG 평가 지표 저장 완료")

    def save_agent_accuracy(self, accuracy_data: Dict):
        """
        Agent 정확도 저장

        Args:
            accuracy_data: Agent 정확도 데이터 딕셔너리
        """
        accuracy_data['timestamp'] = datetime.now().isoformat()

        with open(self.evaluation_dir / "agent_accuracy.json", 'w', encoding='utf-8') as f:
            json.dump(accuracy_data, f, ensure_ascii=False, indent=2)

        self.logger.write("Agent 정확도 저장 완료")

    def save_latency_report(self, latency_data: Dict):
        """
        응답 시간 분석 저장

        Args:
            latency_data: 응답 시간 데이터 딕셔너리
        """
        latency_data['timestamp'] = datetime.now().isoformat()

        with open(self.evaluation_dir / "latency_report.json", 'w', encoding='utf-8') as f:
            json.dump(latency_data, f, ensure_ascii=False, indent=2)

        self.logger.write("응답 시간 분석 저장 완료")

    def save_cost_analysis(self, cost_data: Dict):
        """
        비용 분석 저장

        Args:
            cost_data: 비용 분석 데이터 딕셔너리
        """
        cost_data['timestamp'] = datetime.now().isoformat()

        with open(self.evaluation_dir / "cost_analysis.json", 'w', encoding='utf-8') as f:
            json.dump(cost_data, f, ensure_ascii=False, indent=2)

        self.logger.write("비용 분석 저장 완료")

    def save_test_results(self, test_data: Dict):
        """
        테스트 결과 저장

        Args:
            test_data: 테스트 결과 데이터 딕셔너리
        """
        test_data['timestamp'] = datetime.now().isoformat()

        with open(self.evaluation_dir / "test_results.json", 'w', encoding='utf-8') as f:
            json.dump(test_data, f, ensure_ascii=False, indent=2)

        self.logger.write("테스트 결과 저장 완료")

    # ===== 디버그 관련 =====

    def save_debug_info(self, filename: str, data: Dict):
        """
        디버그 정보 저장

        Args:
            filename: 파일명
            data: 디버그 데이터
        """
        # debug 폴더가 없으면 생성
        self.debug_dir.mkdir(exist_ok=True)

        debug_path = self.debug_dir / filename
        with open(debug_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)

    # ===== 메타데이터 관련 =====

    def update_metadata(self, **kwargs):
        """
        메타데이터 업데이트

        Args:
            **kwargs: 업데이트할 키-값 쌍
        """
        self.metadata.update(kwargs)

        with open(self.metadata_file, 'w', encoding='utf-8') as f:
            json.dump(self.metadata, f, ensure_ascii=False, indent=2)

        self.logger.write(f"메타데이터 업데이트: {list(kwargs.keys())}")

    def save_config(self, config: Dict):
        """
        전체 설정 저장

        Args:
            config: 설정 딕셔너리
        """
        config_path = self.experiment_dir / "config.yaml"
        with open(config_path, 'w', encoding='utf-8') as f:
            yaml.dump(config, f, allow_unicode=True, sort_keys=False)

        self.logger.write("설정 파일 저장 완료")

    def close(self):
        """실험 종료"""
        # 종료 시간 기록
        self.metadata['end_time'] = datetime.now().isoformat()

        # 최종 메타데이터 저장
        with open(self.metadata_file, 'w', encoding='utf-8') as f:
            json.dump(self.metadata, f, ensure_ascii=False, indent=2)

        self.logger.write("=" * 50)
        self.logger.write("실험 종료")
        self.logger.write("=" * 50)
        self.logger.close()

    def __enter__(self):
        """with 문 지원"""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """with 문 종료 시 자동 close"""
        self.close()
```

---

## 실제 사용 예시

### main.py

```python
from src.utils.experiment_manager import ExperimentManager
from src.agent.graph import create_agent
from src.llm.client import LLMClient
import time

def main():
    # 1. 실험 매니저 초기화
    with ExperimentManager() as exp:

        # 2. UI 인터랙션 기록
        exp.log_ui_interaction("페이지 접속")
        exp.log_ui_interaction("사이드바 열기")

        # 3. 난이도 선택
        difficulty = "easy"
        exp.log_ui_interaction(f"난이도 선택: {difficulty}")
        exp.log_ui_event({
            "event_type": "difficulty_changed",
            "old_value": None,
            "new_value": difficulty
        })

        # 4. 사용자 질문
        question = "RAG에 대해 알려줘"
        exp.log_ui_interaction(f"질문 입력: {question}")
        exp.log_ui_event({
            "event_type": "message_submitted",
            "message_length": len(question)
        })

        # 5. 메타데이터 업데이트
        exp.update_metadata(
            user_query=question,
            difficulty=difficulty
        )

        # 6. 프롬프트 생성
        system_prompt = """당신은 논문을 쉽게 설명하는 전문가입니다.

[역할]
- 초보자도 이해할 수 있도록 쉬운 용어 사용
- 비유와 예시를 많이 활용
- 전문 용어는 풀어서 설명
- 한글로 친절하게 답변"""

        exp.save_system_prompt(system_prompt, {
            "난이도": difficulty,
            "생성 시간": time.time(),
            "템플릿": "EASY_SYSTEM_PROMPT"
        })

        # 7. Agent 실행
        exp.logger.write("Agent 실행 시작")
        start_time = time.time()

        agent = create_agent()
        result = agent.invoke({
            "question": question,
            "difficulty": difficulty
        })

        response_time_ms = int((time.time() - start_time) * 1000)

        # 8. 사용된 도구에 따라 로그 기록
        tool_used = result.get('tool_used', 'unknown')
        exp.update_metadata(tool_used=tool_used)

        if tool_used == 'rag_paper':
            # 도구별 Logger
            tool_logger = exp.get_tool_logger('rag_paper')
            tool_logger.write("논문 검색 시작")
            tool_logger.write(f"검색 쿼리: {question}")

            # pgvector 검색 기록
            exp.log_pgvector_search({
                "tool": "rag_paper",
                "collection": "paper_chunks",
                "query_text": question,
                "embedding_dimension": 1536,
                "search_type": "similarity",
                "top_k": 5,
                "execution_time_ms": 45
            })

            # SQL 쿼리 기록
            exp.log_sql_query(
                query="""SELECT paper_id, title, authors, publish_date
FROM papers
WHERE paper_id IN (123, 456, 789, 234, 567)""",
                description="논문 메타데이터 조회",
                tool="rag_paper",
                execution_time_ms=12
            )

            # 검색 결과 저장
            exp.save_search_results("rag_paper", {
                "query": question,
                "difficulty": difficulty,
                "results_count": 5,
                "papers": [
                    {
                        "paper_id": 123,
                        "title": "Retrieval-Augmented Generation...",
                        "authors": "Patrick Lewis, et al.",
                        "relevance_score": 0.92
                    }
                    # ... 더 많은 결과
                ]
            })

            tool_logger.write("논문 검색 완료")
            tool_logger.close()

        # 9. 사용자 프롬프트 저장
        user_prompt = f"""[참고 논문]
1. Retrieval-Augmented Generation (Patrick Lewis et al., 2020)
   ...

[질문]
{question}

위 논문을 참고하여 초보자가 이해하기 쉽게 답변해주세요."""

        exp.save_user_prompt(user_prompt, {
            "검색 결과 수": 5,
            "컨텍스트 길이": 1234,
            "도구": tool_used
        })

        # 10. 최종 답변 저장
        final_answer = result['final_answer']
        exp.save_output('response.txt', final_answer)

        # 11. 프롬프트 템플릿 정보 저장
        exp.save_prompt_template({
            "difficulty": difficulty,
            "template_name": "EASY_SYSTEM_PROMPT",
            "llm_config": {
                "model": "gpt-4",
                "temperature": 0.7,
                "max_tokens": 2000
            },
            "token_count": {
                "system": 234,
                "user": 1234,
                "total": 1468
            }
        })

        # 12. UI 이벤트 기록
        exp.log_ui_event({
            "event_type": "response_received",
            "response_length": len(final_answer),
            "response_time_ms": response_time_ms
        })

        # 13. DB 성능 정보 저장
        exp.save_db_performance({
            "summary": {
                "total_queries": 4,
                "total_execution_time_ms": 120
            },
            "queries": [
                {
                    "query_type": "pgvector_similarity",
                    "execution_time_ms": 45
                },
                {
                    "query_type": "select",
                    "table": "papers",
                    "execution_time_ms": 12
                }
            ]
        })

        # 14. 최종 메타데이터 업데이트
        exp.update_metadata(
            success=True,
            response_time_ms=response_time_ms,
            response_length=len(final_answer)
        )

        exp.logger.write(f"최종 답변 생성 완료 ({response_time_ms}ms)")

        # 15. ExperimentManager는 with 문이 끝나면 자동으로 close()

if __name__ == "__main__":
    main()
```

---

## 폴더 검색 및 분석

### scripts/find_experiments.py

```python
import json
from pathlib import Path
from typing import Optional, List, Dict

def find_experiments(
    difficulty: Optional[str] = None,
    tool: Optional[str] = None,
    date: Optional[str] = None,
    min_response_time: Optional[int] = None,
    max_response_time: Optional[int] = None
) -> List[Dict]:
    """
    메타데이터 기반 실험 검색

    Returns:
        검색된 실험 목록
    """
    results = []

    # 검색 경로
    if date:
        search_path = Path(f"experiments/{date}")
        if not search_path.exists():
            return []
    else:
        search_path = Path("experiments")

    # 모든 metadata.json 찾기
    for meta_file in search_path.rglob("metadata.json"):
        try:
            with open(meta_file, encoding='utf-8') as f:
                meta = json.load(f)
        except Exception:
            continue

        # 필터 적용
        if difficulty and meta.get('difficulty') != difficulty:
            continue
        if tool and meta.get('tool_used') != tool:
            continue
        if min_response_time and meta.get('response_time_ms', 0) < min_response_time:
            continue
        if max_response_time and meta.get('response_time_ms', float('inf')) > max_response_time:
            continue

        results.append({
            'path': meta_file.parent,
            'metadata': meta
        })

    results.sort(key=lambda x: x['metadata'].get('start_time', ''))
    return results

if __name__ == "__main__":
    # 사용 예시
    easy_experiments = find_experiments(difficulty="easy")
    print(f"Easy 모드 실험: {len(easy_experiments)}개")

    for exp in easy_experiments:
        print(f"  - {exp['path'].name}: {exp['metadata']['user_query']}")
```

---

## 참고 문서

- [05_로깅_시스템.md](../PRD/05_로깅_시스템.md) - Logger 클래스 사용법
- [06_실험_추적_관리.md](../PRD/06_실험_추적_관리.md) - 실험 폴더 규칙
- [11_데이터베이스_설계.md](../PRD/11_데이터베이스_설계.md) - DB 스키마
- [15_프롬프트_엔지니어링.md](../PRD/15_프롬프트_엔지니어링.md) - 프롬프트 설계
- [16_UI_설계.md](../PRD/16_UI_설계.md) - Streamlit UI
- [담당역할_06_로깅_모니터링.md](../roles/담당역할_06_로깅_모니터링.md) - 로깅 담당 역할

---

## 버전 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|-----------|
| 1.0 | 2025-10-31 | 초안 작성 - 종합 폴더 구조 정의 |
