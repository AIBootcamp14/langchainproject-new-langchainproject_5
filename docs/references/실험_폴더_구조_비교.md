# 실험 폴더 구조 비교 가이드

## 문서 정보
- **작성일**: 2025-10-31
- **프로젝트명**: 논문 리뷰 챗봇 (AI Agent + RAG)
- **팀명**: 연결의 민족
- **목적**: experiments 폴더 구조 및 명명 전략 비교

---

## 개요

프로젝트 실행 시 `experiments/` 폴더에 실험 결과를 저장할 때, 폴더명 생성 및 메타데이터 관리 전략에 따라 세 가지 방법을 비교합니다.

### 핵심 이슈

챗봇 프로그램 실행 시:
1. **프로그램 시작** → Logger 초기화 및 폴더 생성
2. **사용자 질문 입력** → Easy/Hard 난이도 선택
3. **AI Agent 실행** → 6가지 도구 중 하나 선택 (search_paper, web_search, glossary, summarize, save_file, general)
4. **결과 저장** → 로그, config, 답변 등 저장

**문제점**: 프로그램 시작 시점에는 난이도/도구 정보를 알 수 없음 → 폴더명에 어떻게 반영할 것인가?

---

## 시나리오 가정

아래 예시는 2025년 10월 31일에 사용자가 3번 실행한 경우를 가정합니다:

| 실행 시간 | 난이도 | 도구 | 사용자 질문 | 응답 시간 |
|----------|--------|------|------------|-----------|
| 10:30:15 | Easy | search_paper | "RAG에 대해 알려줘" | 2.5초 |
| 14:25:43 | Hard | web_search | "최신 Transformer 논문 찾아줘" | 3.2초 |
| 16:48:20 | Easy | glossary | "BERT가 뭐야?" | 1.2초 |

---

## 방법 1: 실행 종료 시 폴더명 변경

### 📁 개념

- **프로그램 시작 시**: 일반적인 폴더명으로 생성
- **실행 중**: 폴더명 유지, 메타데이터는 내부 파일로 저장
- **프로그램 종료 시**: Logger 파일 닫은 후 폴더명 자동 변경

### 🗂️ 폴더 구조

#### 실행 중 (변경 전)
```
experiments/
└── 20251031/
    ├── 20251031_103015_chatbot_session/    # 🟡 실행 중 - 일반적인 이름
    │   ├── experiment.log                   # ⚠️ Logger가 파일 OPEN 중
    │   ├── config.yaml                      # difficulty: easy, tool: search_paper
    │   └── response.txt
    │
    ├── 20251031_142543_chatbot_session/    # 🟡 실행 중
    │   ├── experiment.log                   # ⚠️ Logger가 파일 OPEN 중
    │   ├── config.yaml
    │   └── response.txt
    │
    └── 20251031_164820_chatbot_session/    # 🟡 실행 중
        ├── experiment.log                   # ⚠️ Logger가 파일 OPEN 중
        ├── config.yaml
        └── response.txt
```

**문제점**: 실행 중에는 모든 폴더명이 `chatbot_session`으로 동일 → 어떤 실험인지 구분 불가

#### 실행 종료 후 (변경 후)
```
experiments/
└── 20251031/
    ├── 20251031_103015_easy_search_paper/  ✅ 종료 시 자동 변경
    │   ├── experiment.log
    │   ├── config.yaml
    │   ├── results.json
    │   └── response.txt
    │
    ├── 20251031_142543_hard_web_search/    ✅ 종료 시 자동 변경
    │   ├── experiment.log
    │   ├── config.yaml
    │   ├── results.json
    │   └── response.txt
    │
    └── 20251031_164820_easy_glossary/      ✅ 종료 시 자동 변경
        ├── experiment.log
        ├── config.yaml
        ├── results.json
        └── response.txt
```

**개선점**: 폴더명만 봐도 어떤 실험인지 명확함

### 💻 구현 예시

```python
class ExperimentManager:
    def __init__(self, experiment_name: str = "chatbot_session"):
        """프로그램 시작 시 일반적인 이름으로 폴더 생성"""
        today = datetime.now().strftime("%Y%m%d")
        time_now = datetime.now().strftime("%H%M%S")

        # 초기 폴더명
        self.experiment_dir = Path(f"experiments/{today}/{today}_{time_now}_{experiment_name}")
        self.experiment_dir.mkdir(parents=True, exist_ok=True)

        # 메타데이터 저장 (나중에 폴더명 변경에 사용)
        self.metadata = {
            'difficulty': None,
            'tool_used': None,
            'original_dir': str(self.experiment_dir)
        }

        # Logger 초기화
        self.logger = Logger(str(self.experiment_dir / "experiment.log"))
        self.logger.write("실험 시작")

    def update_metadata(self, difficulty: str, tool_used: str):
        """첫 질문 처리 후 메타데이터 업데이트"""
        self.metadata['difficulty'] = difficulty
        self.metadata['tool_used'] = tool_used

        # config.yaml에 즉시 저장
        config_path = self.experiment_dir / "config.yaml"
        with open(config_path, 'w', encoding='utf-8') as f:
            yaml.dump(self.metadata, f, allow_unicode=True)

        self.logger.write(f"메타데이터 업데이트: {difficulty}_{tool_used}")

    def close(self):
        """실행 종료 시 폴더명 변경"""
        # 1. Logger 파일 닫기
        self.logger.write("실험 종료 - 폴더명 변경 시작")
        self.logger.close()

        # 2. 메타데이터 기반으로 새 폴더명 생성
        if self.metadata['difficulty'] and self.metadata['tool_used']:
            # 기존 시간 정보 추출
            dir_parts = self.experiment_dir.name.split('_')
            date = dir_parts[0]
            time = dir_parts[1]

            # 새 폴더명 생성
            new_name = f"{date}_{time}_{self.metadata['difficulty']}_{self.metadata['tool_used']}"
            new_dir = self.experiment_dir.parent / new_name

            # 3. 폴더명 변경
            try:
                self.experiment_dir.rename(new_dir)
                print(f"폴더명 변경 완료: {self.experiment_dir.name} -> {new_name}")
                self.experiment_dir = new_dir
            except Exception as e:
                print(f"폴더명 변경 실패: {e}")
```

### 📊 장단점

#### ✅ 장점
1. **안전성**: Logger 파일이 완전히 닫힌 후 폴더명 변경 → 파일 핸들 문제 없음
2. **간단함**: 폴더명 변경 로직이 한 곳(close)에만 집중
3. **명확한 결과**: 종료 후 폴더명만 봐도 실험 내용 파악 가능
4. **OS 호환성**: Windows에서도 안전하게 동작

#### ❌ 단점
1. **실행 중 구분 불가**: 실행 중에는 모든 폴더명이 동일
2. **비정상 종료**: 프로그램이 중간에 종료되면 폴더명이 변경되지 않음
3. **디버깅 어려움**: 실행 중 폴더를 열어봐도 어떤 모드/도구인지 모름

### 🎯 추천 상황
- 단일 사용자가 순차적으로 실행
- 실행이 안정적으로 완료되는 환경
- 폴더명 변경의 안전성이 가장 중요한 경우

---

## 방법 2: 첫 질문 후 즉시 폴더명 변경

### 📁 개념

- **프로그램 시작 시**: `pending` 폴더로 생성
- **첫 질문 처리 직후**: Logger 재시작 후 폴더명 즉시 변경
- **실행 중/종료 후**: 변경된 폴더명 유지

### 🗂️ 폴더 구조

#### 실행 시작 직후 (질문 받기 전)
```
experiments/
└── 20251031/
    ├── 20251031_103015_pending/            # 🟡 아직 질문 받지 않음
    │   └── experiment.log                   # "프로그램 시작" 로그만
    │
    ├── 20251031_142543_pending/            # 🟡 아직 질문 받지 않음
    │   └── experiment.log
    │
    └── 20251031_164820_pending/            # 🟡 아직 질문 받지 않음
        └── experiment.log
```

#### 첫 질문 처리 직후 (폴더명 즉시 변경)
```
experiments/
└── 20251031/
    ├── 20251031_103015_easy_search_paper/  ✅ 첫 질문 후 즉시 변경
    │   ├── experiment.log                   # Logger 재시작됨
    │   ├── config.yaml
    │   └── ... (계속 작업 중)
    │
    ├── 20251031_142543_hard_web_search/    ✅ 첫 질문 후 즉시 변경
    │   ├── experiment.log
    │   └── ... (계속 작업 중)
    │
    └── 20251031_164820_easy_glossary/      ✅ 첫 질문 후 즉시 변경
        ├── experiment.log
        └── ... (계속 작업 중)
```

#### 실행 종료 후
```
experiments/
└── 20251031/
    ├── 20251031_103015_easy_search_paper/  # 변경 없음 (이미 변경됨)
    │   ├── experiment.log
    │   ├── config.yaml
    │   ├── results.json
    │   └── response.txt
    │
    ├── 20251031_142543_hard_web_search/
    │   ├── experiment.log
    │   ├── config.yaml
    │   ├── results.json
    │   └── response.txt
    │
    └── 20251031_164820_easy_glossary/
        ├── experiment.log
        ├── config.yaml
        ├── results.json
        └── response.txt
```

### 💻 구현 예시

```python
class ExperimentManager:
    def __init__(self, experiment_name: str = "pending"):
        """초기에는 'pending'으로 시작"""
        today = datetime.now().strftime("%Y%m%d")
        time_now = datetime.now().strftime("%H%M%S")

        # 임시 폴더명
        self.temp_dir = Path(f"experiments/{today}/{today}_{time_now}_{experiment_name}")
        self.temp_dir.mkdir(parents=True, exist_ok=True)

        # Logger 초기화
        self.logger = Logger(str(self.temp_dir / "experiment.log"))
        self.logger.write("실험 시작 - 사용자 질문 대기 중")

        # 상태 플래그
        self.renamed = False
        self.experiment_dir = self.temp_dir

    def rename_after_first_query(self, difficulty: str, tool_used: str):
        """첫 질문 처리 직후 폴더명 변경"""
        if self.renamed:
            self.logger.write("이미 폴더명이 변경되었습니다.")
            return

        # 1. 변경 전 로그 기록
        self.logger.write(f"폴더명 변경 시작: {difficulty}_{tool_used}")

        # 2. Logger 파일 닫기
        self.logger.close()

        # 3. 새 폴더명 생성
        dir_parts = self.temp_dir.name.split('_')
        date = dir_parts[0]
        time = dir_parts[1]
        new_name = f"{date}_{time}_{difficulty}_{tool_used}"
        new_dir = self.temp_dir.parent / new_name

        # 4. 폴더명 변경
        try:
            self.temp_dir.rename(new_dir)
            self.experiment_dir = new_dir

            # 5. 새 경로로 Logger 재생성 (append 모드)
            self.logger = Logger(str(self.experiment_dir / "experiment.log"))
            self.logger.write(f"폴더명 변경 완료: {new_name}")

            self.renamed = True

        except Exception as e:
            # 실패 시 원래 Logger 복구
            self.logger = Logger(str(self.temp_dir / "experiment.log"))
            self.logger.write(f"폴더명 변경 실패: {e}", print_error=True)
            raise

    def close(self):
        """실행 종료"""
        self.logger.write("실험 종료")
        self.logger.close()
```

### 🔧 main.py 사용 예시

```python
from src.utils.experiment_manager import ExperimentManager
from src.agent.graph import create_agent

# 1. 프로그램 시작 - pending 폴더 생성
exp = ExperimentManager("pending")

# 2. 사용자 질문 받기
print("논문 리뷰 챗봇을 시작합니다.")
question = input("질문을 입력하세요: ")
difficulty = input("난이도를 선택하세요 (easy/hard): ")

# 3. Agent 실행
agent = create_agent()
result = agent.invoke({
    "question": question,
    "difficulty": difficulty
})

tool_used = result.get('tool_used', 'unknown')

# 4. 첫 질문 처리 후 즉시 폴더명 변경
exp.rename_after_first_query(difficulty, tool_used)

# 5. 결과 저장
exp.logger.write(f"사용자 질문: {question}")
exp.logger.write(f"최종 답변: {result['final_answer']}")

# 6. 종료
exp.close()
```

### 📊 장단점

#### ✅ 장점
1. **실시간 반영**: 첫 질문 처리 후 즉시 폴더명으로 확인 가능
2. **실행 중 구분**: 여러 세션 동시 실행 시 폴더명으로 구분 가능
3. **디버깅 용이**: 실행 중에도 폴더명이 의미 있음

#### ❌ 단점
1. **복잡도 증가**: Logger를 닫고 다시 열어야 함
2. **타이밍 이슈**: 폴더명 변경 시점에 예외 처리 필요
3. **OS 의존성**: 일부 OS에서 파일 열린 상태에서 폴더명 변경 불가능할 수 있음

### 🎯 추천 상황
- 개발/디버깅 단계
- 실행 중 폴더명으로 즉시 확인이 필요한 경우
- 비교적 짧은 실행 시간 (Logger 재시작 오버헤드 감수 가능)

---

## 방법 3: 메타데이터 파일 활용 (추천 ⭐)

### 📁 개념

- **프로그램 시작 시**: 고유 session ID로 폴더 생성
- **실행 중**: `metadata.json` 파일에 난이도/도구 정보 즉시 저장
- **실행 종료 후**: 폴더명 변경 없이 메타데이터로 검색/필터링

### 🗂️ 폴더 구조

#### 실행 중 및 종료 후 (폴더명 항상 동일 패턴)
```
experiments/
└── 20251031/
    ├── 20251031_103015_session_001/        # 고유 ID로 관리
    │   ├── metadata.json ⭐                # 난이도/도구 정보
    │   ├── experiment.log
    │   ├── config.yaml
    │   ├── results.json
    │   └── response.txt
    │
    ├── 20251031_142543_session_002/        # 고유 ID로 관리
    │   ├── metadata.json ⭐
    │   ├── experiment.log
    │   ├── config.yaml
    │   ├── results.json
    │   └── response.txt
    │
    └── 20251031_164820_session_003/        # 고유 ID로 관리
        ├── metadata.json ⭐
        ├── experiment.log
        ├── config.yaml
        ├── results.json
        └── response.txt
```

### 📄 metadata.json 파일 내용

#### session_001 (첫 번째 실행)
```json
{
  "session_id": "001",
  "difficulty": "easy",
  "tool_used": "search_paper",
  "start_time": "2025-10-31T10:30:15",
  "end_time": "2025-10-31T10:32:45",
  "user_query": "RAG에 대해 알려줘",
  "success": true,
  "response_time_ms": 2500,
  "tokens_used": {
    "prompt": 1200,
    "completion": 800,
    "total": 2000
  },
  "model": "gpt-4",
  "response_length": 450
}
```

#### session_002 (두 번째 실행)
```json
{
  "session_id": "002",
  "difficulty": "hard",
  "tool_used": "web_search",
  "start_time": "2025-10-31T14:25:43",
  "end_time": "2025-10-31T14:28:10",
  "user_query": "최신 Transformer 논문 찾아줘",
  "success": true,
  "response_time_ms": 3200,
  "tokens_used": {
    "prompt": 1500,
    "completion": 1200,
    "total": 2700
  },
  "model": "gpt-4",
  "response_length": 680
}
```

#### session_003 (세 번째 실행)
```json
{
  "session_id": "003",
  "difficulty": "easy",
  "tool_used": "glossary",
  "start_time": "2025-10-31T16:48:20",
  "end_time": "2025-10-31T16:49:05",
  "user_query": "BERT가 뭐야?",
  "success": true,
  "response_time_ms": 1200,
  "tokens_used": {
    "prompt": 800,
    "completion": 500,
    "total": 1300
  },
  "model": "solar-pro",
  "response_length": 320
}
```

### 💻 구현 예시

```python
import json
from pathlib import Path
from datetime import datetime

class ExperimentManager:
    def __init__(self):
        """프로그램 시작 시 고유 session ID로 폴더 생성"""
        today = datetime.now().strftime("%Y%m%d")
        time_now = datetime.now().strftime("%H%M%S")

        # 당일 session ID 생성
        session_id = self._get_next_session_id(today)

        # 폴더명: 날짜_시간_session_XXX
        self.experiment_dir = Path(
            f"experiments/{today}/{today}_{time_now}_session_{session_id:03d}"
        )
        self.experiment_dir.mkdir(parents=True, exist_ok=True)

        # 메타데이터 초기화
        self.metadata = {
            'session_id': f"{session_id:03d}",
            'start_time': datetime.now().isoformat(),
            'difficulty': None,
            'tool_used': None,
            'user_query': None,
            'success': None,
            'response_time_ms': None,
            'end_time': None
        }

        # metadata.json 파일 경로
        self.metadata_file = self.experiment_dir / "metadata.json"

        # Logger 초기화
        self.logger = Logger(str(self.experiment_dir / "experiment.log"))
        self.logger.write(f"세션 시작: session_{session_id:03d}")

    def _get_next_session_id(self, date: str) -> int:
        """당일 다음 session ID 반환"""
        date_dir = Path(f"experiments/{date}")

        if not date_dir.exists():
            return 1

        # 기존 session 폴더 찾기
        existing_sessions = list(date_dir.glob(f"{date}_*_session_*"))

        if not existing_sessions:
            return 1

        # 마지막 session ID 추출
        max_id = 0
        for session_dir in existing_sessions:
            try:
                # "20251031_103015_session_001" -> "001"
                session_id_str = session_dir.name.split('_')[-1]
                session_id = int(session_id_str)
                max_id = max(max_id, session_id)
            except (IndexError, ValueError):
                continue

        return max_id + 1

    def update_metadata(self, **kwargs):
        """메타데이터 업데이트 및 즉시 저장"""
        self.metadata.update(kwargs)

        # metadata.json에 즉시 저장
        with open(self.metadata_file, 'w', encoding='utf-8') as f:
            json.dump(self.metadata, f, ensure_ascii=False, indent=2)

        self.logger.write(f"메타데이터 업데이트: {kwargs}")

    def save_config(self, config: dict):
        """실험 설정 저장"""
        config_path = self.experiment_dir / "config.yaml"

        with open(config_path, 'w', encoding='utf-8') as f:
            yaml.dump(config, f, allow_unicode=True)

        self.logger.write(f"설정 파일 저장: {config_path}")

    def save_results(self, results: dict):
        """실험 결과 저장"""
        results_path = self.experiment_dir / "results.json"

        with open(results_path, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2)

        self.logger.write(f"결과 파일 저장: {results_path}")

    def close(self):
        """실행 종료"""
        # 종료 시간 기록
        self.metadata['end_time'] = datetime.now().isoformat()

        # 최종 메타데이터 저장
        with open(self.metadata_file, 'w', encoding='utf-8') as f:
            json.dump(self.metadata, f, ensure_ascii=False, indent=2)

        self.logger.write("실험 종료")
        self.logger.close()
```

### 🔧 main.py 사용 예시

```python
from src.utils.experiment_manager import ExperimentManager
from src.agent.graph import create_agent
import time

# 1. 실험 시작
exp = ExperimentManager()

# 2. 사용자 질문 받기
question = input("질문을 입력하세요: ")
difficulty = input("난이도를 선택하세요 (easy/hard): ")

# 3. 메타데이터 즉시 업데이트
exp.update_metadata(
    user_query=question,
    difficulty=difficulty
)

# 4. Agent 실행
start_time = time.time()
agent = create_agent()
result = agent.invoke({
    "question": question,
    "difficulty": difficulty
})
response_time = int((time.time() - start_time) * 1000)

# 5. 메타데이터 최종 업데이트
exp.update_metadata(
    tool_used=result.get('tool_used', 'unknown'),
    success=True,
    response_time_ms=response_time,
    response_length=len(result['final_answer'])
)

# 6. 결과 저장
exp.save_results(result)

# 7. 종료
exp.close()
```

### 🔍 검색 유틸리티

#### scripts/find_experiments.py

```python
import json
from pathlib import Path
from typing import Optional, List, Dict

def find_experiments(
    difficulty: Optional[str] = None,
    tool: Optional[str] = None,
    date: Optional[str] = None,
    min_response_time: Optional[int] = None,
    max_response_time: Optional[int] = None
) -> List[Dict]:
    """
    메타데이터 기반 실험 검색

    Args:
        difficulty: 'easy' 또는 'hard'
        tool: 도구명 (search_paper, web_search, glossary 등)
        date: 날짜 (YYYYMMDD)
        min_response_time: 최소 응답 시간 (밀리초)
        max_response_time: 최대 응답 시간 (밀리초)

    Returns:
        검색된 실험 목록
    """
    results = []

    # 검색 경로 설정
    if date:
        search_path = Path(f"experiments/{date}")
        if not search_path.exists():
            return []
    else:
        search_path = Path("experiments")

    # 모든 metadata.json 파일 찾기
    for meta_file in search_path.rglob("metadata.json"):
        try:
            with open(meta_file, encoding='utf-8') as f:
                meta = json.load(f)
        except Exception as e:
            print(f"메타데이터 읽기 실패: {meta_file}, {e}")
            continue

        # 필터 적용
        if difficulty and meta.get('difficulty') != difficulty:
            continue

        if tool and meta.get('tool_used') != tool:
            continue

        if min_response_time and meta.get('response_time_ms', 0) < min_response_time:
            continue

        if max_response_time and meta.get('response_time_ms', float('inf')) > max_response_time:
            continue

        # 결과 추가
        results.append({
            'path': meta_file.parent,
            'metadata': meta
        })

    # 시작 시간 순 정렬
    results.sort(key=lambda x: x['metadata'].get('start_time', ''))

    return results


def print_experiment_summary(experiments: List[Dict]):
    """실험 목록 요약 출력"""
    print(f"\n총 {len(experiments)}개의 실험을 찾았습니다.\n")
    print("-" * 100)
    print(f"{'세션 ID':<10} {'난이도':<8} {'도구':<15} {'응답시간':<10} {'질문':<40}")
    print("-" * 100)

    for exp in experiments:
        meta = exp['metadata']
        print(
            f"{meta.get('session_id', 'N/A'):<10} "
            f"{meta.get('difficulty', 'N/A'):<8} "
            f"{meta.get('tool_used', 'N/A'):<15} "
            f"{meta.get('response_time_ms', 0):<10} "
            f"{meta.get('user_query', 'N/A')[:40]:<40}"
        )

    print("-" * 100)


# 사용 예시
if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='실험 검색')
    parser.add_argument('--difficulty', choices=['easy', 'hard'], help='난이도')
    parser.add_argument('--tool', help='도구명')
    parser.add_argument('--date', help='날짜 (YYYYMMDD)')
    parser.add_argument('--min-time', type=int, help='최소 응답 시간 (ms)')
    parser.add_argument('--max-time', type=int, help='최대 응답 시간 (ms)')

    args = parser.parse_args()

    results = find_experiments(
        difficulty=args.difficulty,
        tool=args.tool,
        date=args.date,
        min_response_time=args.min_time,
        max_response_time=args.max_time
    )

    print_experiment_summary(results)
```

#### 검색 예시

```bash
# Easy 모드 실험만 찾기
python scripts/find_experiments.py --difficulty easy

# 출력:
# 총 2개의 실험을 찾았습니다.
# ----------------------------------------------------------------------------------------------------
# 세션 ID    난이도    도구             응답시간    질문
# ----------------------------------------------------------------------------------------------------
# 001        easy      search_paper    2500       RAG에 대해 알려줘
# 003        easy      glossary        1200       BERT가 뭐야?
# ----------------------------------------------------------------------------------------------------

# 응답 시간이 3초 이상 걸린 실험 찾기
python scripts/find_experiments.py --min-time 3000

# 출력:
# 총 1개의 실험을 찾았습니다.
# ----------------------------------------------------------------------------------------------------
# 세션 ID    난이도    도구             응답시간    질문
# ----------------------------------------------------------------------------------------------------
# 002        hard      web_search      3200       최신 Transformer 논문 찾아줘
# ----------------------------------------------------------------------------------------------------

# 특정 날짜의 search_paper 도구 사용 실험 찾기
python scripts/find_experiments.py --date 20251031 --tool search_paper

# 출력:
# 총 1개의 실험을 찾았습니다.
# ----------------------------------------------------------------------------------------------------
# 세션 ID    난이도    도구             응답시간    질문
# ----------------------------------------------------------------------------------------------------
# 001        easy      search_paper    2500       RAG에 대해 알려줘
# ----------------------------------------------------------------------------------------------------
```

### 📊 통계 분석 예시

```python
# scripts/analyze_experiments.py

import json
from pathlib import Path
from collections import Counter
import statistics

def analyze_experiments(date: str = None):
    """실험 통계 분석"""

    # 검색 경로
    if date:
        search_path = Path(f"experiments/{date}")
    else:
        search_path = Path("experiments")

    # 데이터 수집
    difficulties = []
    tools = []
    response_times = []

    for meta_file in search_path.rglob("metadata.json"):
        try:
            with open(meta_file, encoding='utf-8') as f:
                meta = json.load(f)

            if meta.get('difficulty'):
                difficulties.append(meta['difficulty'])
            if meta.get('tool_used'):
                tools.append(meta['tool_used'])
            if meta.get('response_time_ms'):
                response_times.append(meta['response_time_ms'])

        except Exception:
            continue

    # 통계 출력
    print("\n=== 실험 통계 분석 ===\n")

    print(f"총 실험 수: {len(difficulties)}")

    print("\n[난이도별 분포]")
    for difficulty, count in Counter(difficulties).items():
        print(f"  {difficulty}: {count}회 ({count/len(difficulties)*100:.1f}%)")

    print("\n[도구별 사용 횟수]")
    for tool, count in Counter(tools).most_common():
        print(f"  {tool}: {count}회 ({count/len(tools)*100:.1f}%)")

    if response_times:
        print("\n[응답 시간 통계]")
        print(f"  평균: {statistics.mean(response_times):.0f}ms")
        print(f"  중앙값: {statistics.median(response_times):.0f}ms")
        print(f"  최소: {min(response_times)}ms")
        print(f"  최대: {max(response_times)}ms")

# 실행
if __name__ == "__main__":
    analyze_experiments(date="20251031")
```

**출력 예시:**
```
=== 실험 통계 분석 ===

총 실험 수: 3

[난이도별 분포]
  easy: 2회 (66.7%)
  hard: 1회 (33.3%)

[도구별 사용 횟수]
  search_paper: 1회 (33.3%)
  web_search: 1회 (33.3%)
  glossary: 1회 (33.3%)

[응답 시간 통계]
  평균: 2300ms
  중앙값: 2500ms
  최소: 1200ms
  최대: 3200ms
```

### 📊 장단점

#### ✅ 장점
1. **안전성**: 폴더명 변경 없음 → 파일 핸들 문제 완전 회피
2. **유연성**: 다양한 조건으로 검색 가능 (응답시간, 토큰 수 등)
3. **확장성**: 메타데이터에 추가 정보 쉽게 추가 가능
4. **동시 실행**: 여러 세션이 동시 실행되어도 충돌 없음
5. **통계 분석**: 전체 실험에 대한 통계 분석 용이
6. **Streamlit 친화적**: UI에서 여러 사용자가 동시 사용 가능

#### ❌ 단점
1. **검색 도구 필요**: 폴더명만으로는 정보 파악 불가 → Python 스크립트 필요
2. **추가 파일**: metadata.json 파일이 추가로 생성됨
3. **학습 곡선**: 검색 스크립트 사용법을 알아야 함

### 🎯 추천 상황
- **프로덕션 환경** (가장 권장 ⭐⭐⭐)
- Streamlit UI로 여러 사용자가 동시 사용
- 실험 결과 분석/통계가 중요한 경우
- 장기적인 확장성이 필요한 경우

---

## 종합 비교표

| 구분 | 방법 1<br/>(종료 시 변경) | 방법 2<br/>(첫 질문 후 변경) | 방법 3<br/>(메타데이터) ⭐ |
|------|----------------------|------------------------|---------------------|
| **폴더명 패턴** | `날짜_시간_난이도_도구` | `날짜_시간_난이도_도구` | `날짜_시간_session_XXX` |
| **실행 중 폴더명** | `chatbot_session` (일반적) | `pending` → 변경됨 | `session_XXX` (고정) |
| **정보 저장 위치** | 폴더명 (종료 후) | 폴더명 (첫 질문 후) | metadata.json |
| **검색 방법** | `ls \| grep` | `ls \| grep` | Python 스크립트 |
| **안전성** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **유연성** | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **확장성** | ⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| **동시 실행** | ⚠️ 주의 필요 | ⚠️ 주의 필요 | ✅ 완벽 지원 |
| **학습 곡선** | ⭐ (쉬움) | ⭐⭐ (보통) | ⭐⭐⭐ (약간 복잡) |
| **비정상 종료** | ❌ 폴더명 변경 안됨 | ✅ 이미 변경됨 | ✅ metadata 보존 |
| **통계 분석** | ⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| **프로덕션 적합도** | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ |

---

## 실제 사용 시나리오 비교

### 시나리오 1: "어제 Easy 모드로 search_paper 쓴 실험 찾기"

**방법 1, 2 (폴더명 기반):**
```bash
cd experiments/20251030
ls | grep "easy_search_paper"

# 결과:
# 20251030_103015_easy_search_paper
# 20251030_164820_easy_search_paper
```
✅ 빠르고 간단

**방법 3 (메타데이터):**
```bash
python scripts/find_experiments.py --date 20251030 --difficulty easy --tool search_paper

# 결과:
# 총 2개의 실험을 찾았습니다.
# ----------------------------------------------------------------------------------------------------
# 세션 ID    난이도    도구             응답시간    질문
# ----------------------------------------------------------------------------------------------------
# 001        easy      search_paper    2500       RAG에 대해 알려줘
# 005        easy      search_paper    1800       BERT 논문 찾아줘
# ----------------------------------------------------------------------------------------------------
```
✅ 더 많은 정보 제공

---

### 시나리오 2: "응답 시간이 3초 이상 걸린 실험 찾기"

**방법 1, 2:**
- ❌ 폴더명만으로는 불가능
- 각 폴더의 results.json을 일일이 열어봐야 함

**방법 3:**
```bash
python scripts/find_experiments.py --min-time 3000

# 결과:
# 총 5개의 실험을 찾았습니다.
# ...
```
✅ 즉시 검색 가능

---

### 시나리오 3: "전체 실험의 평균 응답 시간 계산"

**방법 1, 2:**
- 수동으로 각 폴더의 results.json 파싱 필요
- 복잡한 스크립트 작성 필요

**방법 3:**
```bash
python scripts/analyze_experiments.py

# 결과:
# === 실험 통계 분석 ===
# 총 실험 수: 50
# 평균 응답 시간: 2345ms
# ...
```
✅ 자동 통계 분석

---

### 시나리오 4: "Streamlit UI에서 10명이 동시 사용"

**방법 1, 2:**
- ⚠️ 폴더명 충돌 가능성
- 동시 폴더명 변경 시 경쟁 상태 발생 가능

**방법 3:**
- ✅ session ID가 자동 증가 → 충돌 없음
- ✅ 각 세션이 독립적으로 metadata.json 관리

---

## 최종 권장 사항

### 🥇 **방법 3 (메타데이터 파일)을 강력 추천**

**이유:**
1. **안전성**: 폴더명 변경 없음 → 파일 핸들 문제 완전 회피
2. **Streamlit 친화적**: 여러 사용자 동시 사용 가능
3. **확장성**: 나중에 새로운 메타데이터 필드 쉽게 추가
4. **분석 용이**: 통계 분석 및 성능 모니터링 쉬움
5. **프로덕션 적합**: 장기적으로 가장 안정적

### 📝 구현 순서

1. **Phase 1**: ExperimentManager 클래스 구현 (방법 3)
2. **Phase 2**: 검색 유틸리티 구현 (find_experiments.py)
3. **Phase 3**: 통계 분석 도구 구현 (analyze_experiments.py)
4. **Phase 4**: main.py에 통합

---

## 참고 자료

- [05_로깅_시스템.md](../PRD/05_로깅_시스템.md)
- [06_실험_추적_관리.md](../PRD/06_실험_추적_관리.md)
- [담당역할_06_로깅_모니터링.md](../roles/담당역할_06_로깅_모니터링.md)

---

## 버전 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|-----------|
| 1.0 | 2025-10-31 | 초안 작성 - 3가지 방법 비교 |
